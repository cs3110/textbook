# Summary

* [Cover Page](README.md)

---

* [1. Introduction](intro/intro.md)
  - [1.1. Programming Languages](intro/pl.md)
  - [1.2. OCaml](intro/ocaml.md)
  - [1.3. Mutability](intro/mutability.md)
  - [1.4. Summary](intro/summary.md)
  - [1.5. Exercises](intro/exercises.md)
  - [1.6. A Brief History of CS 3110](intro/history.md)

---

* [2. The Basics of OCaml](basics/intro.md)
  - [2.1. Interacting with OCaml](basics/interacting.md)
  - [2.2. Expressions](basics/expressions.md)
    + [2.2.1. Operators](basics/operators.md)
    + [2.2.2. If Expressions](basics/if_expressions.md)
    + [2.2.3. Let Expressions](basics/let_expressions.md)
    + [2.2.4. Scope](basics/scope.md)
  - [2.3. Functions](basics/functions.md)
    + [2.3.1. Anonymous Functions](basics/anonymous_functions.md)
    + [2.3.2. Function Application](basics/function_application.md)
    + [2.3.3. Polymorphic Functions](basics/polymorphic_functions.md)
    + [2.3.4. Labeled and Optional Arguments](basics/arguments.md)
    + [2.3.5. Partial Application](basics/partial_application.md)
    + [2.3.6. Operators as Functions](basics/operators_functions.md)
    + [2.3.7. Documentation](basics/documentation.md)
    + [2.3.8. Preconditions and Postconditions](basics/pre_post_conditions.md)    
  - [2.4. Debugging](basics/debugging.md)
    + [2.4.1. Printing](basics/printing.md)
    + [2.4.2. Defensive Programming](basics/defensive.md)
  - [2.5. Summary](basics/summary.md)
  - [2.6. Exercises](basics/exercises.md)
  
* [3. Data in OCaml](data/intro.md)
  - [3.1. Standard Data Types](data/standard.md)
	+ [3.1.1. Lists](data/lists.md)
	  * [3.1.1.1. Building Lists](data/building_lists.md)
	  * [3.1.1.2. Accessing Lists](data/accessing_lists.md)
	  * [3.1.1.3. Mutating Lists](data/mutating_lists.md)
	  * [3.1.1.4. Pattern Matching with Lists](data/pattern_matching_lists.md)
	  * [3.1.1.5. Tail Recursion](data/tail_recursion.md)
	  * [3.1.1.6. More List Syntax](data/more_list_syntax.md)
	+ [3.1.2. Variants](data/variants.md)
	+ [3.1.3. Unit Testing with OUnit](data/ounit.md)
	  * [3.1.3.1. An Example of OUnit](data/ounit_example.md)
	  * [3.1.3.2. Explanation of the OUnit Example](data/ounit_explanation.md)
	  * [3.1.3.3. Improving OUnit Output](data/ounit_improved_output.md)
	  * [3.1.3.4. OUnit and Files](data/ounit_files.md)
	  * [3.1.3.5. Test-driven Development](data/tdd.md)
	+ [3.1.4. Records](data/records.md)
	+ [3.1.5. Tuples](data/tuples.md)
	+ [3.1.6. One-of vs. Each-of](data/oneof_eachof.md)
	+ [3.1.7. Advanced Pattern Matching](data/pattern_matching_advanced.md)
	  * [3.1.7.1. Pattern Matching with Let](data/pattern_matching_let.md)
	  * [3.1.7.2. Pattern Matching with Functions](data/pattern_matching_functions.md)
	  * [3.1.7.3. Pattern Matching Examples](data/pattern_matching_examples.md)
  - [3.2. Advanced Data Types](data/advanced.md)
	+ [3.2.1. Options](data/options.md)
	+ [3.2.2. Association Lists](data/assoc_list.md)
	+ [3.2.3. Type Synonyms](data/type_synonym.md)
	+ [3.2.4. Algebraic Data Types](data/algebraic_data_types.md)
	  * [3.2.4.1. Catch-all Cases](data/catch_all_cases.md)
	  * [3.2.4.2. Recursive Variants](data/recursive_variants.md)
	  * [3.2.4.3. Parameterized Variants](data/parameterized_variants.md)
	  * [3.2.4.4. Polymorphic Variants](data/polymorphic_variants.md)
	  * [3.2.4.5. Built-in Variants](data/builtin_variants.md)
	+ [3.2.5. Exceptions](data/exceptions.md)
	+ [3.2.6. Example: Trees](data/trees.md)
	+ [3.2.7. Example: Natural Numbers](data/nats.md)
  - [3.3. Summary](data/summary.md)
  - [3.4. Exercises](data/exercises.md)
  
* [4. Higher-order Programming](hop/intro.md)
  - [4.1. The Meaning of "Higher Order"](hop/higher_order.md)
  - [4.2. The Abstraction Principle](hop/abstraction_principle.md)
  - [4.3. Famous Higher-order Functions](hop/famous_hof.md)
	+ [4.3.1. Map](hop/map.md)
	+ [4.3.2. Filter](hop/filter.md)
	+ [4.3.3. Fold Right](hop/fold_right.md)
	+ [4.3.4. Fold Left](hop/fold_left.md)
	+ [4.3.5. Fold Left vs. Fold Right](hop/fold_left_vs_right.md)
	+ [4.3.6. Using Fold](hop/using_fold.md)
	+ [4.3.7. Fold vs. Recursive vs. Library](hop/fold_vs_rec_vs_lib.md)
	+ [4.3.8. Fold with Trees](hop/fold_trees.md)
	+ [4.3.9. Generalized Folds](hop/generalized_fold.md)
  - [4.4. Pipelining](hop/pipelining.md)
  - [4.5. Currying](hop/currying.md)
  - [4.6. Summary](hop/summary.md)
  - [4.7. Exercises](hop/exercises.md)

* [5. Modules](modules/intro.md)
  - [5.1. Module Systems](modules/module_systems.md)
  - [5.2. OCaml Modules](modules/ocaml_modules.md)
    + [5.2.1. Structures](modules/structures.md)
	+ [5.2.2. Scope](modules/scope.md)
	+ [5.2.3. Signatures](modules/signatures.md)
    + [5.2.4. Abstract Types](modules/abstract_types.md)	
    + [5.2.5. Semantics of Modules](modules/semantics_modules.md)    
    + [5.2.6. Functional Data Structures](modules/functional_data_structures.md)
	  * [5.2.6.1. Example: Stacks](modules/ex_stacks.md)
	  * [5.2.6.2. Example: Queues](modules/ex_queues.md)
	  * [5.2.6.3. Example: Dictionaries](modules/ex_dictionaries.md)
	  * [5.2.6.4. Example: Sets](modules/ex_sets.md)
	  * [5.2.6.5. Example: Arithmetic](modules/ex_arithmetic.md)
    + [5.2.7. Sharing Constraints](modules/sharing_constraints.md)
    + [5.2.8. Compilation Units](modules/compilation_units.md)
    + [5.2.9. Modules and the Toplevel](modules/toplevel.md)
  - [5.3. Code Reuse with Modules](modules/reuse.md)
	+ [5.3.1. Includes](modules/includes.md)
	  * [5.3.1.1. Semantics of Includes](modules/semantics_includes.md)
	  * [5.3.1.2. Encapsulation and Includes](modules/encapsulation_includes.md)
	  * [5.3.1.3. Include vs. Open](modules/include_vs_open.md)
	  * [5.3.1.4. Including Code in Multiple Modules](modules/include_multiple.md)
	* [5.3.2. Functors](modules/functors.md)
	  * [5.3.2.1. Functor Syntax](modules/functor_syntax.md)
	  * [5.3.2.2. Using Functors](modules/using_functors.md)
	  * [5.3.2.3. Example: Standard Library Map](modules/stdlib_map.md)
  - [5.4. Summary](modules/summary.md)
  - [5.5. Exercises](modules/exercises.md)
  
* [6. Specifications and Abstraction](abstract/intro.md)
  - [6.1. Specification of Functions](abstract/function_specs.md)
  - [6.2. The Specification Game](abstract/game.md)
  - [6.3. Comments](abstract/comments.md)
  - [6.4. Specification of Modules](abstract/module_specs.md)
  - [6.5. Abstraction Functions](abstract/af.md)
  - [6.6. Commutative Diagrams](abstract/commutative.md)
  - [6.7. Representation Invariants](abstract/ri.md)
  - [6.8. Implementing the Representation Invariant](abstract/impl_ri.md)
  - [6.9. Summary](abstract/summary.md)
  - [6.10. Exercises](abstract/exercises.md)
  
* [7. Testing](testing/intro.md)
  - [7.1. Test Coverage](testing/coverage.md)
  - [7.2. Black-box Testing](testing/blackbox.md)
  - [7.3. Glass-box Testing](testing/glassbox.md)
  - [7.4. Bisect](testing/bisect.md)
  - [7.5. Testing Data Abstractions](testing/data_abstractions.md)
  - [7.6. Faults](testing/faults.md)
  - [7.7. Randomized Testing](testing/randomized.md)
  - [7.8. Random Number Generation](testing/random.md)
  - [7.9. \*QCheck](testing/qcheck.md)
  - [7.10. Summary](testing/summary.md)
  - [7.11. Exercises](testing/exercises.md)

- [8. Mutability](mut/intro.md)
  - [8.1. Refs](mut/refs.md)
  - [8.2. Refs: Syntax and Semantics](mut/refs_ss.md)
  - [8.3. Sequencing](mut/sequencing.md)
  - [8.4. Example: Mutable Counter](mut/ex_counter.md)
  - [8.5. Example: Recursion Without Rec](mut/ex_recursion_without_rec.md)
  - [8.6. Physical Equality](mut/physical_equality.md)
  - [8.7. Mutable Fields](mut/mutable_fields.md)
  - [8.8. Example: Mutable Stack](mut/ex_mutable_stack.md)
  - [8.9. Arrays and Loops](mut/arrays.md)
  - [8.10. Summary](mut/summary.md)
  - [8.11. Exercises](mut/exercises.md)

- [9. Efficiency](eff/intro.md)
  - [9.1. Defining Efficiency](eff/defining.md)
    - [9.1.1 Algorithms and Efficiency, Attempt 1](eff/eff1.md)
    - [9.1.2 Algorithms and Efficiency, Attempt 2](eff/eff2.md)       
    - [9.1.3 Big-Oh Notation](eff/bigoh.md)
    - [9.1.4 Algorithms and Efficiency, Attempt 3](eff/eff3.md)       
  - [9.2. Efficient Maps](eff/eff_maps.md)
    - [9.2.1. Association Lists](eff/map_assoclist.md)
    - [9.2.2. Direct Address Tables](eff/map_dat.md)
    - [9.2.3. Hash Tables](eff/map_hash.md)
  - [9.3. Amortized Analysis](eff/amortized.md)
    - [9.3.1. Amortized Analysis of Hash Tables](eff/amortized_hash.md)
    - [9.3.2. Amortized Analysis of Two-List Queues](eff/amortized_queue.md)
    - [9.3.3. Bankers and Physicists](eff/amortized_methods.md)
    - [9.3.4. Amortized Analysis and Persistence](eff/amortized_persistence.md)
  - [9.4. Functional Maps](eff/funmaps.md)
     - [9.4.1. Binary Search Trees](eff/bst.md)
     - [9.4.2. Red-Black Trees](eff/rb.md)
     - [9.4.3. Maps and Sets from BSTs](eff/bst_maps.md)     
  - [9.5. Summary](eff/summary.md)
  - [9.6. Exercises](eff/exercises.md) 

* [10. Interpreters](interp/intro.md)
  - [10.1. Lexing and Parsing](interp/lex_parse.md)
    - [10.1.1. Backus-Naur Form](interp/bnf.md)
	  - [10.1.2. Example: SimPL](interp/simpl.md)
	  - [10.1.3. A Front-End for SimPL](interp/simpl_frontend.md)
  - [10.2. Evaluation: The Substitution Model](interp/evaluation.md)
	  - [10.2.1. Evaluating SimPL in the Substitution Model](interp/simpl_subst_model.md)
	  - [10.2.2. Substitution in SimPL](interp/subst_simpl.md)
	  - [10.2.3. Capture-Avoiding Substitution](interp/subst_lambda.md)
	  - [10.2.4. Core OCaml](interp/core_ocaml.md)
	  - [10.2.5. Evaluating Core OCaml in the Substitution Model](interp/core_ocaml_subst_model.md)
  - [10.3. Evaluation: The Environment Model](interp/env_model.md)
	  - [10.3.1. Evaluating the Lambda Calculus in the Environment Model](interp/lambda_env_model.md)
	  - [10.3.2. Evaluating Core OCaml in the Environment Model](interp/core_ocaml_env_model.md)
  - [10.4. Type Checking](interp/typecheck.md)
	  - [10.4.1. A Type System for SimPL](interp/simpl_typesystem.md)
	  - [10.4.2. A Type Checker for SimPL](interp/simpl_typecheck.md)
	  - [10.4.3. Type Safety](interp/typesafety.md)
  - [10.5. Type Inference](interp/inference.md)
    - [10.5.1. Type Constraints](interp/constraints.md)
    - [10.5.2. Solving Constraints](interp/unification.md)
    - [10.5.3. Finishing Type Inference](interp/reconstruction.md)
    - [10.5.4. Let Polymorphism](interp/letpoly.md)
  - [10.6. Summary](interp/summary.md)
  - [10.7. Exercises](interp/exercises.md)
  
* [11. Proofs about Programs](fm/intro.md) 
  - [11.1. Equality](fm/eq.md)
  - [11.2. Equational Reasoning](fm/eq_reasoning.md)
  - [11.3. Induction on Integers](fm/induction_int.md)    
  - [11.4. Programs as Specifications](fm/prog_as_spec.md)
  - [11.5. Recursion vs Iteration](fm/rec_vs_it.md)
  - [11.6. Termination](fm/termination.md)
  - [11.7. Induction on Variants](fm/induction_variants.md)
    - [11.7.1. Induction on Naturals](fm/induction_nats.md)
    - [11.7.2. Induction on Lists](fm/induction_lists.md)
    - [11.7.3. A Theorem about Folding](fm/theorem_fold.md)    
    - [11.7.4. Induction on Trees](fm/induction_trees.md)  
    - [11.7.5. \*Induction Principles for All Variants](fm/induction_general.md)
  - [11.8. Algebraic Specification](fm/alg_spec.md)
    - [11.8.1. Example: Stacks](fm/alg_spec_stack.md)
    - [11.8.2. Example: Queues](fm/alg_spec_queue.md)
    - [11.8.3. Example: Two-List Queues](fm/alg_spec_tlqueue.md)
  - [11.9. Designing Algebraic Specifications](fm/alg_spec_eqs.md)    
  - [11.10. Summary](fm/summary.md)
  - [11.11. Exercises](fm/exercises.md)
  
* [12. Advanced Topics](adv/intro.md)
  - [12.1. Infinite Data Structures](adv/infinite.md)
	- [12.1.1. Streams](adv/streams.md)
	- [12.1.2. Programming with Streams](adv/stream_progs.md)
	- [12.1.3. Laziness](adv/lazy.md)
  - [12.2. Concurrency](adv/concurrency.md)
	- [12.2.1. Promises](adv/promises.md)
	- [12.2.3. Asynchronous I/O](adv/asynch_io.md)
	- [12.2.4. Callbacks](adv/callbacks.md)
	- [12.2.5. Implementing Callbacks](adv/implementing_callbacks.md)
  - [12.3. Monads](adv/monads.md)
	- [12.3.1. Example: The Maybe Monad](adv/ex_maybe_monad.md)
	- [12.3.2. Example: The Writer Monad](adv/ex_writer_monad.md)
	- [12.3.3. Example: The Lwt Monad](adv/ex_lwt_monad.md)
	- [12.3.4. Monad Laws](adv/monad_laws.md)
  - [12.4. The Curry-Howard Correspondence](adv/curry-howard.md)
  - [12.5. \*Memoization](adv/memoization.md)
  - [12.6. Summary](adv/summary.md)
  - [12.7. Exercises](adv/exercises.md)  

