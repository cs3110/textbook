# Look to Your Future

{{ video_embed | replace("%%VID%%", "SKr3ItChPSI")}}

General-purpose languages come and go. In your life you'll likely learn a
handful. Today, it's Python and Java. Yesterday, it was Pascal and Cobol. Before
that, it was Fortran and Lisp. Who knows what it will be tomorrow? In this
fast-changing field you need to be able to rapidly adapt. A good programmer has
to learn the principles behind programming that transcend the specifics of any
specific language. There's no better way to get at these principles than to
approach programming from a functional perspective. Learning a new language from
scratch affords the opportunity to reflect along the way about the difference
between *programming* and programming *in a language.*

If after OCaml you want to learn more about functional programming, you'll be
well prepared. OCaml does a great job of clarifying and simplifying the essence
of functional programming in a way that other languages that blend functional
and imperative programming (like Scala) or take functional programming to the
extreme (like Haskell) do not.

And even if you never code in OCaml again after learning it, you'll still be
better prepared for the future. Advanced features of functional languages have a
surprising tendency to predict new features of more mainstream languages. Java
brought garbage collection into the mainstream in 1995; Lisp had it in 1958.
Java didn't have generics until version 5 in 2004; the ML family had it in 1990.
First-class functions, type inference, and pattern matching have been incorporated into mainstream
languages like Python, Java, and C++, long after functional languages introduced them.
