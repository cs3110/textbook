
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7.1. Refs &#8212; OCaml Programming: Correct + Efficient + Beautiful</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e8e5499552300ddf5d7adccae7cc3b70.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="7.2. Mutable Fields" href="mutable_fields.html" />
    <link rel="prev" title="7. Mutability" href="intro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/lambda-light.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">OCaml Programming: Correct + Efficient + Beautiful</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <p class="caption">
 <span class="caption-text">
  Preface
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../preface/about.html">
   About This Book
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../intro/intro.html">
   1. Better Programming Through OCaml
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/past.html">
     1.1. The Past of OCaml
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/present.html">
     1.2. The Present of OCaml
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/future.html">
     1.3. Look to Your Future
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/3110.html">
     1.4. A Brief History of CS 3110
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/summary.html">
     1.5. Summary
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../basics/intro.html">
   2. The Basics of OCaml
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/toplevel.html">
     2.1. The OCaml Toplevel
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/compiling.html">
     2.2. Compiling OCaml Programs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/expressions.html">
     2.3. Expressions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/functions.html">
     2.4. Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/documentation.html">
     2.5. Documentation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/printing.html">
     2.6. Printing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/debugging.html">
     2.7. Debugging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/summary.html">
     2.8. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../basics/exercises.html">
     2.9. Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  OCaml Programming
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../data/intro.html">
   3. Data and Types
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/lists.html">
     3.1. Lists
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/variants.html">
     3.2. Variants
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/ounit.html">
     3.3. Unit Testing with OUnit
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/records_tuples.html">
     3.4. Records and Tuples
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/pattern_matching_advanced.html">
     3.5. Advanced Pattern Matching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/type_synonym.html">
     3.6. Type Synonyms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/options.html">
     3.7. Options
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/assoc_list.html">
     3.8. Association Lists
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/algebraic_data_types.html">
     3.9. Algebraic Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/exceptions.html">
     3.10. Exceptions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/trees.html">
     3.11. Example: Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/nats.html">
     3.12. Example: Natural Numbers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/summary.html">
     3.13. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../data/exercises.html">
     3.14. Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../hop/intro.html">
   4. Higher-Order Programming
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/higher_order.html">
     4.1. Higher-Order Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/map.html">
     4.2. Map
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/filter.html">
     4.3. Filter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/fold.html">
     4.4. Fold
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/beyond_lists.html">
     4.5. Beyond Lists
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/pipelining.html">
     4.6. Pipelining
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/currying.html">
     4.7. Currying
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/summary.html">
     4.8. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../hop/exercises.html">
     4.9. Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../modules/intro.html">
   5. Modular Programming
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/module_systems.html">
     5.1. Module Systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/modules.html">
     5.2. Modules
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/toplevel.html">
     5.3. Modules and the Toplevel
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/encapsulation.html">
     5.4. Encapsulation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/functional_data_structures.html">
     5.5. Functional Data Structures
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/module_type_constraints.html">
     5.6. Module Type Constraints
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/compilation_units.html">
     5.7. Compilation Units
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/includes.html">
     5.8. Includes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/functors.html">
     5.9. Functors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/summary.html">
     5.10. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../modules/exercises.html">
     5.11. Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Correctness and Efficiency
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../correctness/intro.html">
   6. Correctness
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/specifications.html">
     6.1. Specifications
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/function_docs.html">
     6.2. Function Documentation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/module_docs.html">
     6.3. Module Documentation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/test_debug.html">
     6.4. Testing and Debugging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/black_glass_box.html">
     6.5. Black-box and Glass-box Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/randomized.html">
     6.6. Randomized Testing with QCheck
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/proving_correctness.html">
     6.7. Proving Correctness
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/structural_induction.html">
     6.8. Structural Induction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/alg_spec.html">
     6.9. Algebraic Specification
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/summary.html">
     6.10. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../correctness/exercises.html">
     6.11. Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="intro.html">
   7. Mutability
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     7.1. Refs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="mutable_fields.html">
     7.2. Mutable Fields
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="arrays.html">
     7.3. Arrays and Loops
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="summary.html">
     7.4. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="exercises.html">
     7.5. Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ds/intro.html">
   8. Data Structures
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/hash_tables.html">
     8.1. Hash Tables
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/amortized.html">
     8.2. Amortized Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/rb.html">
     8.3. Red-Black Trees
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/sequence.html">
     8.4. Sequences
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/memoization.html">
     8.5. Memoization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/promises.html">
     8.6. Promises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/monads.html">
     8.7. Monads
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/summary.html">
     8.8. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ds/exercises.html">
     8.9. Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../appendix/bigoh.html">
   Big-Oh Notation
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../../_sources/chapters/mut/refs.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/chapters/mut/refs.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/cs3110/textbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/cs3110/textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/mut/refs.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/cs3110/textbook/edit/jupyter/src/chapters/mut/refs.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/cs3110/textbook/jupyter?urlpath=tree/src/chapters/mut/refs.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#aliasing">
   7.1.1. Aliasing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#syntax-and-semantics">
   7.1.2. Syntax and Semantics
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sequencing-of-effects">
   7.1.3. Sequencing of Effects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-mutable-counter">
   7.1.4. Example: Mutable Counter
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-pointers">
   7.1.5. Example: Pointers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-recursion-without-rec">
   7.1.6. Example: Recursion Without Rec
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#weak-type-variables">
   7.1.7. Weak Type Variables
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#physical-equality">
   7.1.8. Physical Equality
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-singly-linked-lists">
   7.1.9. Example: Singly-linked Lists
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="refs">
<h1><span class="section-number">7.1. </span>Refs<a class="headerlink" href="#refs" title="Permalink to this headline">¶</a></h1>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/R0tGac0jaEQ" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>A <em>ref</em> is like a pointer or reference in an imperative language. It is a
location in memory whose contents may change. Refs are also called <em>ref cells</em>,
the idea being that there’s a cell in memory that can change.</p>
<p>Here’s an example of creating a ref, getting the value from inside it, changing
its contents, and observing the changed contents:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val x : int ref = {contents = 0}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">x</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">x</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
</div>
</div>
<p>The first phrase, <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ref</span> <span class="pre">0</span></code>, creates a reference using the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword.
That’s a location in memory whose contents are initialized to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Think of the
location itself as being an address—for example, 0x3110bae0—even
though there’s no way to write down such an address in an OCaml program. The
keyword <code class="docutils literal notranslate"><span class="pre">ref</span></code> is what causes the memory location to be allocated and
initialized.</p>
<p>The first part of the response from OCaml, <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">ref</span></code>, indicates that <code class="docutils literal notranslate"><span class="pre">x</span></code>
is a variable whose type is <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ref</span></code>. We have a new type constructor here. Much
like <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">option</span></code> are type constructors, so is <code class="docutils literal notranslate"><span class="pre">ref</span></code>. A <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">ref</span></code>, for any
type <code class="docutils literal notranslate"><span class="pre">t</span></code>, is a reference to a memory location that is guaranteed to contain a
value of type <code class="docutils literal notranslate"><span class="pre">t</span></code>. As usual we should read a type from right to left: <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">ref</span></code>
means a reference to a <code class="docutils literal notranslate"><span class="pre">t</span></code>. The second part of the response shows us the
contents of the memory location. Indeed, the contents have been initialized to
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The second phrase, <code class="docutils literal notranslate"><span class="pre">!x</span></code>, dereferences <code class="docutils literal notranslate"><span class="pre">x</span></code> and returns the contents of the memory
location. Note that <code class="docutils literal notranslate"><span class="pre">!</span></code> is the dereference operator in OCaml, not Boolean
negation.</p>
<p>The third phrase, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">1</span></code>, is an assignment. It mutates the contents <code class="docutils literal notranslate"><span class="pre">x</span></code> to be
<code class="docutils literal notranslate"><span class="pre">1</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> itself still points to the same location (i.e., address) in
memory. Memory is mutable; variable bindings are not. What changes is the
contents. The response from OCaml is simply <code class="docutils literal notranslate"><span class="pre">()</span></code>, meaning that the assignment
took place—much like printing functions return <code class="docutils literal notranslate"><span class="pre">()</span></code> to indicate that the
printing did happen.</p>
<p>The fourth phrase, <code class="docutils literal notranslate"><span class="pre">!x</span></code> again dereferences <code class="docutils literal notranslate"><span class="pre">x</span></code> to demonstrate that the contents
of the memory location did indeed change.</p>
<div class="section" id="aliasing">
<h2><span class="section-number">7.1.1. </span>Aliasing<a class="headerlink" href="#aliasing" title="Permalink to this headline">¶</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/pt06BxGhjDQ" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Now that we have refs, we have <em>aliasing</em>: two refs could point to the same
memory location, hence updating through one causes the other to also be updated.
For example,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">42</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">42</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">;;</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">43</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="o">!</span><span class="n">y</span> <span class="o">+</span> <span class="o">!</span><span class="n">z</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val x : int ref = {contents = 42}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val y : int ref = {contents = 42}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val z : int ref = {contents = 42}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val w : int = 85
</pre></div>
</div>
</div>
</div>
<p>The result of executing that code is that <code class="docutils literal notranslate"><span class="pre">w</span></code> is bound to <code class="docutils literal notranslate"><span class="pre">85</span></code>, because
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span></code> causes <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> to become aliases, hence updating <code class="docutils literal notranslate"><span class="pre">x</span></code> to be <code class="docutils literal notranslate"><span class="pre">43</span></code>
also causes <code class="docutils literal notranslate"><span class="pre">z</span></code> to be <code class="docutils literal notranslate"><span class="pre">43</span></code>.</p>
</div>
<div class="section" id="syntax-and-semantics">
<h2><span class="section-number">7.1.2. </span>Syntax and Semantics<a class="headerlink" href="#syntax-and-semantics" title="Permalink to this headline">¶</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/ByV1N3hDgSw" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The semantics of refs is based on <em>locations</em> in memory. Locations are values
that can be passed to and returned from functions. But unlike other values
(e.g., integers, variants), there is no way to directly write a location in an
OCaml program. That’s different than languages like C, in which programmers can
directly write memory addresses and do arithmetic on pointers. C programmers
want that kind of low-level access to do things like interface with hardware and
build operating systems. Higher-level programmers are willing to forego it to
get <em>memory safety</em>. That’s a hard term to define, but according to
<a class="reference external" href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/">Hicks 2014</a> it intuitively means that</p>
<ul class="simple">
<li><p>pointers are only created in a safe way that defines their legal memory
region,</p></li>
<li><p>pointers can only be dereferenced if they point to their allotted memory
region,</p></li>
<li><p>that region is (still) defined.</p></li>
</ul>
<p><strong>Syntax.</strong></p>
<ul class="simple">
<li><p>Ref creation: <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">e</span></code></p></li>
<li><p>Ref assignment: <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:=</span> <span class="pre">e2</span></code></p></li>
<li><p>Dereference: <code class="docutils literal notranslate"><span class="pre">!e</span></code></p></li>
</ul>
<p><strong>Dynamic semantics.</strong></p>
<ul class="simple">
<li><p>To evaluate <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">e</span></code>,</p>
<ul>
<li><p>Evaluate <code class="docutils literal notranslate"><span class="pre">e</span></code> to a value <code class="docutils literal notranslate"><span class="pre">v</span></code></p></li>
<li><p>Allocate a new location <code class="docutils literal notranslate"><span class="pre">loc</span></code> in memory to hold <code class="docutils literal notranslate"><span class="pre">v</span></code></p></li>
<li><p>Store <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">loc</span></code></p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">loc</span></code></p></li>
</ul>
</li>
<li><p>To evaluate <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:=</span> <span class="pre">e2</span></code>,</p>
<ul>
<li><p>Evaluate <code class="docutils literal notranslate"><span class="pre">e2</span></code> to a value <code class="docutils literal notranslate"><span class="pre">v</span></code>, and <code class="docutils literal notranslate"><span class="pre">e1</span></code> to a location <code class="docutils literal notranslate"><span class="pre">loc</span></code>.</p></li>
<li><p>Store <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">loc</span></code>.</p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">()</span></code>, i.e., unit.</p></li>
</ul>
</li>
<li><p>To evaluate <code class="docutils literal notranslate"><span class="pre">!e</span></code>,</p>
<ul>
<li><p>Evaluate <code class="docutils literal notranslate"><span class="pre">e</span></code> to a location <code class="docutils literal notranslate"><span class="pre">loc</span></code>.</p></li>
<li><p>Return the contents of <code class="docutils literal notranslate"><span class="pre">loc</span></code>.</p></li>
</ul>
</li>
</ul>
<p><strong>Static semantics.</strong></p>
<p>We have a new type constructor, <code class="docutils literal notranslate"><span class="pre">ref</span></code>, such that <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">ref</span></code> is a type for any type
<code class="docutils literal notranslate"><span class="pre">t</span></code>. Note that the <code class="docutils literal notranslate"><span class="pre">ref</span></code> keyword is used in two ways: as a type constructor, and
as an expression that constructs refs.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">ref</span></code> if  <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:=</span> <span class="pre">e2</span> <span class="pre">:</span> <span class="pre">unit</span></code> if <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">ref</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span> <span class="pre">:</span> <span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!e</span> <span class="pre">:</span> <span class="pre">t</span></code> if <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">ref</span></code>.</p></li>
</ul>
</div>
<div class="section" id="sequencing-of-effects">
<h2><span class="section-number">7.1.3. </span>Sequencing of Effects<a class="headerlink" href="#sequencing-of-effects" title="Permalink to this headline">¶</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/aj0bpOyv7Gs" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The semicolon operator is used to sequence effects, such as mutating refs. We’ve
seen semicolon occur previously with printing. Now that we’re studying
mutability, it’s time to treat it formally.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2</span></code></p></li>
<li><p><strong>Dynamic semantics:</strong> To evaluate <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2</span></code>,</p>
<ul>
<li><p>First evaluate <code class="docutils literal notranslate"><span class="pre">e1</span></code> to a value <code class="docutils literal notranslate"><span class="pre">v1</span></code>.</p></li>
<li><p>Then evaluate <code class="docutils literal notranslate"><span class="pre">e2</span></code> to a value <code class="docutils literal notranslate"><span class="pre">v2</span></code>.</p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">v2</span></code>.  (<code class="docutils literal notranslate"><span class="pre">v1</span></code> is not used at all.)</p></li>
<li><p>If there are multiple expressions in a sequence, e.g., <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2;</span> <span class="pre">...;</span> <span class="pre">en</span></code>,
then evaluate each one in order from left to right, returning only <code class="docutils literal notranslate"><span class="pre">vn</span></code>.
Another way to think about this is that semicolon is right
associative—for example <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2;</span> <span class="pre">e3</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">(e2;</span> <span class="pre">e3))</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Static semantics:</strong> <code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2</span> <span class="pre">:</span> <span class="pre">t</span></code> if <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:</span> <span class="pre">unit</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span> <span class="pre">:</span> <span class="pre">t</span></code>. Similarly,
<code class="docutils literal notranslate"><span class="pre">e1;</span> <span class="pre">e2;</span> <span class="pre">...;</span> <span class="pre">en</span> <span class="pre">:</span> <span class="pre">t</span></code> if <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:</span> <span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">e2</span> <span class="pre">:</span> <span class="pre">unit</span></code>, … (i.e., all expressions
except <code class="docutils literal notranslate"><span class="pre">en</span></code> have type <code class="docutils literal notranslate"><span class="pre">unit</span></code>), and <code class="docutils literal notranslate"><span class="pre">en</span> <span class="pre">:</span> <span class="pre">t</span></code>.</p></li>
</ul>
<p>The typing rule for semicolon is designed to prevent programmer mistakes. For
example, a programmer who writes <code class="docutils literal notranslate"><span class="pre">2+3;</span> <span class="pre">7</span></code> probably didn’t mean to: there’s no
reason to evaluate <code class="docutils literal notranslate"><span class="pre">2+3</span></code> then throw away the result and instead return <code class="docutils literal notranslate"><span class="pre">7</span></code>. The
compiler will give you a warning if you violate this particular typing rule.</p>
<p>To get rid of the warning (if you’re sure that’s what you need to do), there’s a
function <code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">:</span> <span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code> in the standard library. Using it,
<code class="docutils literal notranslate"><span class="pre">ignore(2+3);</span> <span class="pre">7</span></code> will compile without a warning. Of course, you could code up
<code class="docutils literal notranslate"><span class="pre">ignore</span></code> yourself: <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">ignore</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">()</span></code>.</p>
</div>
<div class="section" id="example-mutable-counter">
<h2><span class="section-number">7.1.4. </span>Example: Mutable Counter<a class="headerlink" href="#example-mutable-counter" title="Permalink to this headline">¶</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/o5wFQvCRJsc" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Here is code that implements a <em>counter</em>. Every time <code class="docutils literal notranslate"><span class="pre">next_val</span></code> is called, it
returns one more than the previous time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">next_val</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">counter</span> <span class="o">:=</span> <span class="o">!</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">!</span><span class="n">counter</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val counter : int ref = {contents = 0}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val next_val : unit -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">next_val</span> <span class="bp">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">next_val</span> <span class="bp">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">next_val</span> <span class="bp">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 3
</pre></div>
</div>
</div>
</div>
<p>In the implementation of <code class="docutils literal notranslate"><span class="pre">next_val</span></code>, there are two expressions separated by
semi-colon. The first expression, <code class="docutils literal notranslate"><span class="pre">counter</span> <span class="pre">:=</span> <span class="pre">!counter</span> <span class="pre">+</span> <span class="pre">1</span></code>, is an assignment
that increments <code class="docutils literal notranslate"><span class="pre">counter</span></code> by 1. The second expression, <code class="docutils literal notranslate"><span class="pre">!counter</span></code>, returns the
newly incremented contents of <code class="docutils literal notranslate"><span class="pre">counter</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">next_val</span></code> function is unusual in that every time we call it, it returns a
different value. That’s quite different than any of the functions we’ve
implemented ourselves so far, which have always been <em>deterministic</em>: for a
given input, they always produced the same output. On the other hand, we’ve seen
some library functions that are <em>nondeterministic</em>, for example, functions in
the <code class="docutils literal notranslate"><span class="pre">Random</span></code> module, and <code class="docutils literal notranslate"><span class="pre">Stdlib.read_line</span></code>. It’s no coincidence that those
happen to be implemented using mutable features.</p>
<p>We could improve our counter in a couple ways. First, there is a library
function <code class="docutils literal notranslate"><span class="pre">incr</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">ref</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code> that increments an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ref</span></code> by 1. Thus it is
like the <code class="docutils literal notranslate"><span class="pre">++</span></code> operator that is familiar from many languages in the C family.
Using it, we could write <code class="docutils literal notranslate"><span class="pre">incr</span> <span class="pre">counter</span></code> instead of <code class="docutils literal notranslate"><span class="pre">counter</span> <span class="pre">:=</span> <span class="pre">!counter</span> <span class="pre">+</span> <span class="pre">1</span></code>.
(There’s also a <code class="docutils literal notranslate"><span class="pre">decr</span></code> function that decrements by 1.)</p>
<p>Second, the way we coded the counter currently exposes the <code class="docutils literal notranslate"><span class="pre">counter</span></code> variable to
the outside world. Maybe we’re prefer to hide it so that clients of <code class="docutils literal notranslate"><span class="pre">next_val</span></code>
can’t directly change it. We could do so by nesting <code class="docutils literal notranslate"><span class="pre">counter</span></code> inside the scope
of <code class="docutils literal notranslate"><span class="pre">next_val</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">next_val</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
    <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span>
    <span class="o">!</span><span class="n">counter</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val next_val : unit -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">counter</span></code> is in scope inside of <code class="docutils literal notranslate"><span class="pre">next_val</span></code>, but not accessible outside that
scope.</p>
<p>When we gave the dynamic semantics of let expressions before, we talked about
substitution. One way to think about the definition of <code class="docutils literal notranslate"><span class="pre">next_val</span></code> is as follows.</p>
<ul>
<li><p>First, the expression <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">0</span></code> is evaluated. That returns a location <code class="docutils literal notranslate"><span class="pre">loc</span></code>,
which is an address in memory. The contents of that address are initialized to
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p>Second, everywhere in the body of the let expression that <code class="docutils literal notranslate"><span class="pre">counter</span></code> occurs, we
substitute for it that location. So we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fun () -&gt; incr loc; !loc
</pre></div>
</div>
</li>
<li><p>Third, that anonymous function is bound to <code class="docutils literal notranslate"><span class="pre">next_val</span></code>.</p></li>
</ul>
<p>So any time <code class="docutils literal notranslate"><span class="pre">next_val</span></code> is called, it increments and returns the contents of that
one memory location <code class="docutils literal notranslate"><span class="pre">loc</span></code>.</p>
<p>Now imagine that we instead had written the following (broken) code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">next_val_broken</span> <span class="o">=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span>
  <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="n">incr</span> <span class="n">counter</span><span class="o">;</span>
  <span class="o">!</span><span class="n">counter</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val next_val_broken : unit -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>It’s only a little different:  the binding of <code class="docutils literal notranslate"><span class="pre">counter</span></code> occurs after
the <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">()</span> <span class="pre">-&gt;</span></code> instead of before.  But it makes a huge difference:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">next_val_broken</span> <span class="bp">()</span><span class="o">;;</span>
<span class="n">next_val_broken</span> <span class="bp">()</span><span class="o">;;</span>
<span class="n">next_val_broken</span> <span class="bp">()</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
</div>
</div>
<p>Every time we call <code class="docutils literal notranslate"><span class="pre">next_val_broken</span></code>, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>: we no longer have a
counter. What’s going wrong here?</p>
<p>The problem is that every time <code class="docutils literal notranslate"><span class="pre">next_val_broken</span></code> is called, the first thing it
does is to evaluate <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">0</span></code> to a new location that is initialized to <code class="docutils literal notranslate"><span class="pre">0</span></code>. That
location is then incremented to <code class="docutils literal notranslate"><span class="pre">1</span></code>, and <code class="docutils literal notranslate"><span class="pre">1</span></code> is returned. <em>Every</em> call to
<code class="docutils literal notranslate"><span class="pre">next_val_broken</span></code> is thus allocating a new ref cell, whereas <code class="docutils literal notranslate"><span class="pre">next_val</span></code>
allocates just <em>one</em> new ref cell.</p>
</div>
<div class="section" id="example-pointers">
<h2><span class="section-number">7.1.5. </span>Example: Pointers<a class="headerlink" href="#example-pointers" title="Permalink to this headline">¶</a></h2>
<p>In languages like C, pointers combine two features: they can be null, and they
can be changed. (Java has a similar construct with object references, but that
term is confusing in our OCaml context since “reference” currently means a ref
cell. So we’ll stick with the word “pointer”.) Let’s code up pointers using
OCaml ref cells.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="n">option</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a pointer = &#39;a ref option
</pre></div>
</div>
</div>
</div>
<p>As usual, read that type right to left. The <code class="docutils literal notranslate"><span class="pre">option</span></code> part of it encodes the fact
that a pointer might be null. We’re using <code class="docutils literal notranslate"><span class="pre">None</span></code> to represent that possibility.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">null</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val null : &#39;a pointer = None
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ref</span></code> part of the type encodes the fact that the contents are mutable. We
can create a helper function to allocate and initialize the contents of a new
pointer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">malloc</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">ref</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val malloc : &#39;a -&gt; &#39;a pointer = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Now we could create a pointer to any value we like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val p : int pointer = Some {contents = 42}
</pre></div>
</div>
</div>
</div>
<p><em>Dereferencing</em> a pointer is the <code class="docutils literal notranslate"><span class="pre">*</span></code> prefix operator in C. It returns the
contents of the pointer, and raises an exception if the pointer is null:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">exception</span> <span class="nc">Segfault</span>

<span class="k">let</span> <span class="n">deref</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ptr</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Segfault</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">r</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>exception Segfault
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val deref : &#39;a pointer -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">deref</span> <span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 42
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">deref</span> <span class="n">null</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="ne">Exception</span>: Segfault.
<span class="n">Raised</span> <span class="n">at</span> <span class="n">deref</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;[17]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">25</span><span class="o">-</span><span class="mi">39</span>
<span class="n">Called</span> <span class="kn">from</span> <span class="nn">Toploop.load_lambda</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;toplevel/toploop.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">212</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">17</span><span class="o">-</span><span class="mi">27</span>
</pre></div>
</div>
</div>
</div>
<p>We could even introduce our own OCaml operator for dereference. We have to put
<code class="docutils literal notranslate"><span class="pre">~</span></code> in front of it to make it parse as a prefix operator, though.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="o">(</span> <span class="o">~*</span> <span class="o">)</span> <span class="o">=</span> <span class="n">deref</span><span class="o">;;</span>
<span class="o">~*</span><span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val ( ~* ) : &#39;a pointer -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 42
</pre></div>
</div>
</div>
</div>
<p>In C, an assignment through a pointer is written <code class="docutils literal notranslate"><span class="pre">*p</span> <span class="pre">=</span> <span class="pre">x</span></code>.  That changes
the memory to which <code class="docutils literal notranslate"><span class="pre">p</span></code> points, making it contain <code class="docutils literal notranslate"><span class="pre">x</span></code>.  We can code up
that operator as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">assign</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ptr</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Segfault</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val assign : &#39;a pointer -&gt; &#39;a -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">assign</span> <span class="n">p</span> <span class="mi">2</span><span class="o">;</span>
<span class="n">deref</span> <span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 2
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">assign</span> <span class="n">null</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="ne">Exception</span>: Segfault.
<span class="n">Raised</span> <span class="n">at</span> <span class="n">assign</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;[21]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">25</span><span class="o">-</span><span class="mi">39</span>
<span class="n">Called</span> <span class="kn">from</span> <span class="nn">Toploop.load_lambda</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;toplevel/toploop.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">212</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">17</span><span class="o">-</span><span class="mi">27</span>
</pre></div>
</div>
</div>
</div>
<p>Again, we could introduce our own OCaml operator for that, though it’s hard to
pick a good symbol involving <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">=</span></code> that won’t be misunderstood as
involving multiplication:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="o">(</span> <span class="o">=*</span> <span class="o">)</span> <span class="o">=</span> <span class="n">assign</span><span class="o">;;</span>
<span class="n">p</span> <span class="o">=*</span> <span class="mi">3</span><span class="o">;;</span>
<span class="o">~*</span><span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val ( =* ) : &#39;a pointer -&gt; &#39;a -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 3
</pre></div>
</div>
</div>
</div>
<p>The one thing we can’t do is treat a pointer as an integer. C allows that,
including taking the address of a variable, which enables <em>pointer arithmetic</em>.
That’s great for efficiency, but also terrible because it leads to all kinds of
program errors and security vulnerabilities.</p>
<div class="admonition-evil-secret admonition">
<p class="admonition-title">Evil Secret</p>
<p>Okay that wasn’t actually true what we just said, but this is dangerous
knowledge that you really shouldn’t even read.  There is an undocumented
function <code class="docutils literal notranslate"><span class="pre">Obj.magic</span></code> that we could use to get a memory address of a ref:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">address</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">pointer</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ptr</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="mi">0</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">magic</span> <span class="n">r</span>

<span class="k">let</span> <span class="o">(</span> <span class="o">~&amp;</span> <span class="o">)</span> <span class="o">=</span> <span class="n">address</span>
</pre></div>
</div>
<p>But you have to promise to never, ever use that function yourself, because it
completely circumvents the safety of the OCaml type system. All bets are off if
you do.</p>
</div>
<p>None of this pointer encoding is part of the OCaml standard library, because you
don’t need it. You can always use refs and options yourself as you need to.
Coding as we just did above is not particularly idiomatic. The reason we did it
was to illustrate the relationship between OCaml refs and C pointers
(equivalently, Java references).</p>
</div>
<div class="section" id="example-recursion-without-rec">
<h2><span class="section-number">7.1.6. </span>Example: Recursion Without Rec<a class="headerlink" href="#example-recursion-without-rec" title="Permalink to this headline">¶</a></h2>
<p>Here’s a neat trick that’s possible with refs:  we can build recursive functions
without ever using the keyword <code class="docutils literal notranslate"><span class="pre">rec</span></code>.  Suppose we want to define a recursive
function such as <code class="docutils literal notranslate"><span class="pre">fact</span></code>, which we would normally write as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fact_rec</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact_rec</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact_rec : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>We want to define that function without using <code class="docutils literal notranslate"><span class="pre">rec</span></code>.  We can begin by
defining a ref to an obviously incorrect version of the function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">fact0</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact0 : (int -&gt; int) ref = {contents = &lt;fun&gt;}
</pre></div>
</div>
</div>
</div>
<p>The way in which <code class="docutils literal notranslate"><span class="pre">fact0</span></code> is incorrect is actually irrelevant. We just need it to
have the right type. We could just as well have used <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">fact0</span></code> clearly doesn’t compute the factorial function.
For example, <span class="math notranslate nohighlight">\(5!\)</span> ought to be 120, but that’s not what <code class="docutils literal notranslate"><span class="pre">fact0</span></code> computes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">fact0</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 5
</pre></div>
</div>
</div>
</div>
<p>Next, we write <code class="docutils literal notranslate"><span class="pre">fact</span></code> as usual, but without <code class="docutils literal notranslate"><span class="pre">rec</span></code>. At the place where we need to
make the recursive call, we instead invoke the function stored inside <code class="docutils literal notranslate"><span class="pre">fact0</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">fact</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="o">!</span><span class="n">fact0</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">fact</span></code> does actually get the right answer for <code class="docutils literal notranslate"><span class="pre">0</span></code>, but not for <code class="docutils literal notranslate"><span class="pre">5</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">fact</span> <span class="mi">0</span><span class="o">;;</span>
<span class="n">fact</span> <span class="mi">5</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 20
</pre></div>
</div>
</div>
</div>
<p>The reason it’s not right for <code class="docutils literal notranslate"><span class="pre">5</span></code> is that the recursive call isn’t actually
to the right function.  We want the recursive call to go to <code class="docutils literal notranslate"><span class="pre">fact</span></code>, not to
<code class="docutils literal notranslate"><span class="pre">fact0</span></code>.  <strong>So here’s the trick:</strong> we mutate <code class="docutils literal notranslate"><span class="pre">fact0</span></code> to point to <code class="docutils literal notranslate"><span class="pre">fact</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">fact0</span> <span class="o">:=</span> <span class="n">fact</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
</div>
</div>
<p>Now when <code class="docutils literal notranslate"><span class="pre">fact</span></code> makes its recursive call and dereferences <code class="docutils literal notranslate"><span class="pre">fact0</span></code>, it gets
back itself!  That makes the computation correct:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">fact</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 120
</pre></div>
</div>
</div>
</div>
<p>Abstracting a little, here’s what we did. We started with a function that is
recursive:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="n">f</span> <span class="n">y</span> <span class="o">...</span>
</pre></div>
</div>
<p>We rewrote it as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f0</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span> <span class="o">!</span><span class="n">f0</span> <span class="n">y</span> <span class="o">...</span>

<span class="n">f0</span> <span class="o">:=</span> <span class="n">f</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">f</span></code> will compute the same result as it did in the version where we defined
it with <code class="docutils literal notranslate"><span class="pre">rec</span></code>.</p>
<p>What’s happening here is sometimes called “tying the recursive knot”: we update
the reference to <code class="docutils literal notranslate"><span class="pre">f0</span></code> to point to <code class="docutils literal notranslate"><span class="pre">f</span></code>, such that when <code class="docutils literal notranslate"><span class="pre">f</span></code> dereferences <code class="docutils literal notranslate"><span class="pre">f0</span></code>, it
gets itself back. The initial function to which we made <code class="docutils literal notranslate"><span class="pre">f0</span></code> point (in this case
the identity function) doesn’t really matter; it’s just there as a placeholder
until we tie the knot.</p>
</div>
<div class="section" id="weak-type-variables">
<h2><span class="section-number">7.1.7. </span>Weak Type Variables<a class="headerlink" href="#weak-type-variables" title="Permalink to this headline">¶</a></h2>
<p>Perhaps you have already tried using the identity function to define <code class="docutils literal notranslate"><span class="pre">fact0</span></code>,
as we mentioned above.  If so, you will have encountered this rather puzzling
output:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">fact0</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact0 : (&#39;_weak1 -&gt; &#39;_weak1) ref = {contents = &lt;fun&gt;}
</pre></div>
</div>
</div>
</div>
<p>What is this strange type for the identity function, <code class="docutils literal notranslate"><span class="pre">'_weak1</span> <span class="pre">-&gt;</span> <span class="pre">'_weak1</span></code>? Why
isn’t it the usual <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code>?</p>
<p>The answer has to do with a particularly tricky interaction between polymorphism
and mutability. In a later chapter on interpreters, we’ll learn how type
inference works, and at that point we’ll be able to explain the problem in
detail. In short, allowing the type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code> for that ref would lead the
possibility of programs that crash at run time because of type errors.</p>
<p>For now, think about it this way: although the <em>value</em> stored in a ref cell is
permitted to change, the <em>type</em> of that value is not. And if OCaml gave
<code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x)</span></code> the type <code class="docutils literal notranslate"><span class="pre">('a</span> <span class="pre">-&gt;</span> <span class="pre">'a)</span> <span class="pre">ref</span></code>, then that cell could first store
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> but later store
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">s</span> <span class="pre">^</span> <span class="pre">&quot;!&quot;</span> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">-&gt;</span> <span class="pre">string</span></code>. That would be the kind of change in type
that is not allowed.</p>
<p>So OCaml uses <em>weak type variables</em> to stand for unknown but not polymorphic
types. These variables always start with <code class="docutils literal notranslate"><span class="pre">_weak</span></code>. Essentially, type inference
for these is just not finished yet. Once you give OCaml enough information, it
will finish type inference and replace the weak type variable with the actual
type:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">fact0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : &#39;_weak1 -&gt; &#39;_weak1 = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">fact0</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">fact0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>After the application of <code class="docutils literal notranslate"><span class="pre">!fact0</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>, OCaml now knows that the function
is meant to have type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. So from then on, that’s the only type
at which it can be used. It can’t, for example, be applied to a string.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="n">fact0</span> <span class="s2">&quot;camel&quot;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s2">&quot;[36]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">7</span><span class="o">-</span><span class="mi">14</span><span class="p">:</span>
<span class="mi">1</span> <span class="o">|</span> <span class="o">!</span>fact0 <span class="s2">&quot;camel&quot;</span>
           <span class="o">^^^^^^^</span>
<span class="ne">Error</span>: This expression has type string but an expression was expected of type
         <span class="nb">int</span>
</pre></div>
</div>
</div>
</div>
<p>If you would like to learn more about weak type variables right now, take a look
at Section 2 of <a class="reference external" href="https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf"><em>Relaxing the value restriction</em></a> by Jacques
Garrigue, or <a class="reference external" href="https://ocaml.org/manual/polymorphism.html">this section</a> of the OCaml manual.</p>
</div>
<div class="section" id="physical-equality">
<h2><span class="section-number">7.1.8. </span>Physical Equality<a class="headerlink" href="#physical-equality" title="Permalink to this headline">¶</a></h2>
<p>OCaml has two equality operators, physical equality and structural equality. The
<a class="reference external" href="https://ocaml.org/api/Stdlib.html">documentation</a> of <code class="docutils literal notranslate"><span class="pre">Stdlib.(==)</span></code> explains physical equality:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code> tests for physical equality of <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code>. On mutable types such
as references, arrays, byte sequences, records with mutable fields and objects
with mutable instance variables, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code> if and only if physical
modification of <code class="docutils literal notranslate"><span class="pre">e1</span></code> also affects <code class="docutils literal notranslate"><span class="pre">e2</span></code>. On non-mutable types, the behavior of
<code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">==</span> <span class="pre">)</span></code> is implementation-dependent; however, it is guaranteed that
<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code> implies <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">e1</span> <span class="pre">e2</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div></blockquote>
<p>One interpretation could be that <code class="docutils literal notranslate"><span class="pre">==</span></code> should be used only when comparing refs
(and other mutable data types) to see whether they point to the same location in
memory. Otherwise, don’t use <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
<p>Structural equality is also explained in the documentation of <code class="docutils literal notranslate"><span class="pre">Stdlib.(=)</span></code>:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">=</span> <span class="pre">e2</span></code> tests for structural equality of <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code>. Mutable structures
(e.g. references and arrays) are equal if and only if their current contents
are structurally equal, even if the two mutable objects are not the same
physical object. Equality between functional values raises <code class="docutils literal notranslate"><span class="pre">Invalid_argument</span></code>.
Equality between cyclic data structures may not terminate.</p>
</div></blockquote>
<p>Structural equality is usually what you want to test. For refs, it checks
whether the contents of the memory location are equal, regardless of whether
they are the same location.</p>
<p>The negation of physical equality is <code class="docutils literal notranslate"><span class="pre">!=</span></code>, and the negation of structural
equality is <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>. This can be hard to remember.</p>
<p>Here are some examples involving equality and refs to illustrate the difference
between structural equality (<code class="docutils literal notranslate"><span class="pre">=</span></code>) and physical equality (<code class="docutils literal notranslate"><span class="pre">==</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">42</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val r1 : int ref = {contents = 42}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val r2 : int ref = {contents = 42}
</pre></div>
</div>
</div>
</div>
<p>A ref is physically equal to itself, but not to another ref that is a different
location in memory:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">==</span> <span class="n">r1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = false
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">!=</span> <span class="n">r2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
</div>
</div>
<p>Two refs that are at different locations in memory but store structurally
equal values are themselves structurally equal:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">=</span> <span class="n">r2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">&lt;&gt;</span> <span class="n">r2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = false
</pre></div>
</div>
</div>
</div>
<p>Two refs that store structurally unequal values are themselves structurally
unequal:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="mi">42</span> <span class="o">&lt;&gt;</span> <span class="n">ref</span> <span class="mi">43</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="example-singly-linked-lists">
<h2><span class="section-number">7.1.9. </span>Example: Singly-linked Lists<a class="headerlink" href="#example-singly-linked-lists" title="Permalink to this headline">¶</a></h2>
<p>OCaml’s built-in singly-linked lists are functional, not imperative. But we can
code up imperative singly-linked lists, of course, with refs. (We could also use
the pointers we invented above, but that only makes the code more complicated.)</p>
<p>We start by defining a type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">node</span></code> for nodes of a list that contains values
of type <code class="docutils literal notranslate"><span class="pre">'a</span></code>.  The <code class="docutils literal notranslate"><span class="pre">next</span></code> field of a node is itself another list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** An [&#39;a node] is a node of a mutable singly-linked list. It contains a value</span>
<span class="c">    of type [&#39;a] and a link to the [next] node. *)</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span> <span class="o">=</span> <span class="o">{</span> <span class="n">next</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">;</span> <span class="k">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">}</span>

<span class="c">(** An [&#39;a mlist] is a mutable singly-linked list with elements of type [&#39;a].</span>
<span class="c">    The [option] represents the possibility that the list is empty.</span>
<span class="c">    RI: The list does not contain any cycles. *)</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="n">ref</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a node = { next : &#39;a mlist; value : &#39;a; }
and &#39;a mlist = &#39;a node option ref
</pre></div>
</div>
</div>
</div>
<p>To create an empty list, we simply return a ref to <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [empty ()] is an empty singly-linked list. *)</span>
<span class="k">let</span> <span class="n">empty</span> <span class="bp">()</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : unit -&gt; &#39;a mlist = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Note the type of <code class="docutils literal notranslate"><span class="pre">empty</span></code>: instead of being a value, it is now a function. This
is typical of functions that create mutable data structures. At the end of this
section, we’ll return to why <code class="docutils literal notranslate"><span class="pre">empty</span></code> <em>has</em> to be a function.</p>
<p>Inserting a new first element just requires creating a new node, linking from
it to the original list, and mutating the list:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [insert_first lst n] mutates mlist [lst] by inserting value [v] as the</span>
<span class="c">    first value in the list. *)</span>
<span class="k">let</span> <span class="n">insert_first</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>
  <span class="n">lst</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">!</span><span class="n">lst</span><span class="o">;</span> <span class="k">value</span> <span class="o">=</span> <span class="n">v</span> <span class="o">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val insert_first : &#39;a mlist -&gt; &#39;a -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Again, note the type of <code class="docutils literal notranslate"><span class="pre">insert_first</span></code>. Rather than returning an <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">mlist</span></code>, it
returns <code class="docutils literal notranslate"><span class="pre">unit</span></code>. This again is typical of functions that modify mutable data
structures.</p>
<p>In both <code class="docutils literal notranslate"><span class="pre">empty</span></code> and <code class="docutils literal notranslate"><span class="pre">insert_first</span></code>, the use of <code class="docutils literal notranslate"><span class="pre">unit</span></code> makes the functions more
like their equivalents in an imperative language. The constructor for an empty
list in Java, for example, might not take any arguments (which is equivalent to
taking <code class="docutils literal notranslate"><span class="pre">unit</span></code>). And the <code class="docutils literal notranslate"><span class="pre">insert_first</span></code> operation for a Java linked list might
return <code class="docutils literal notranslate"><span class="pre">void</span></code>, which is equivalent to returning <code class="docutils literal notranslate"><span class="pre">unit</span></code>.</p>
<p>Finally, here’s a conversion function from our new mutable lists to
OCaml’s built-in lists:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [to_list lst] is an OCaml list containing the same values as [lst]</span>
<span class="c">    in the same order. Not tail recursive. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">to_list</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">!</span><span class="n">lst</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span><span class="o">;</span> <span class="k">value</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="k">value</span> <span class="o">::</span> <span class="n">to_list</span> <span class="n">next</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val to_list : &#39;a mlist -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Now we can see mutability in action:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">lst0</span> <span class="o">=</span> <span class="n">empty</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">lst1</span> <span class="o">=</span> <span class="n">lst0</span><span class="o">;;</span>
<span class="n">insert_first</span> <span class="n">lst0</span> <span class="mi">1</span><span class="o">;;</span>
<span class="n">to_list</span> <span class="n">lst1</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val lst0 : &#39;_weak2 mlist = {contents = None}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val lst1 : &#39;_weak2 mlist = {contents = None}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [1]
</pre></div>
</div>
</div>
</div>
<p>The change to <code class="docutils literal notranslate"><span class="pre">lst0</span></code> mutates <code class="docutils literal notranslate"><span class="pre">lst1</span></code>, because they are aliases.</p>
<p><strong>The type of <code class="docutils literal notranslate"><span class="pre">empty</span></code>.</strong> Returning to <code class="docutils literal notranslate"><span class="pre">empty</span></code>, why must it be a function? It
might seem as though we could define it more simply as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : &#39;_weak3 option ref = {contents = None}
</pre></div>
</div>
</div>
</div>
<p>But that would be committing the same mistake as when we broke the counter
above.  Now there is only ever <em>one</em> ref that gets created, hence there
is only one list ever in existence:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">lst2</span> <span class="o">=</span> <span class="n">empty</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">lst3</span> <span class="o">=</span> <span class="n">empty</span><span class="o">;;</span>
<span class="n">insert_first</span> <span class="n">lst2</span> <span class="mi">2</span><span class="o">;;</span>
<span class="n">insert_first</span> <span class="n">lst3</span> <span class="mi">3</span><span class="o">;;</span>
<span class="n">to_list</span> <span class="n">lst2</span><span class="o">;;</span>
<span class="n">to_list</span> <span class="n">lst3</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val lst2 : &#39;_weak3 option ref = {contents = None}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val lst3 : &#39;_weak3 option ref = {contents = None}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [3; 2]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [3; 2]
</pre></div>
</div>
</div>
</div>
<p>Note how the mutations affect both lists, because they are both aliases
for the same ref.</p>
<p>By correctly making <code class="docutils literal notranslate"><span class="pre">empty</span></code> a function, we guarantee that a new ref is
returned every time an empty list is created.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">empty</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : unit -&gt; &#39;a option ref = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>It really doesn’t matter what argument that function takes, since it will
never use it.  We could define it as any of these in principle:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">empty</span> <span class="o">_</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
<span class="k">let</span> <span class="n">empty</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
<span class="k">let</span> <span class="n">empty</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>
<span class="c">(* etc. *)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : &#39;a -&gt; &#39;b option ref = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : bool -&gt; &#39;a option ref = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : int -&gt; &#39;a option ref = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>But the reason we prefer <code class="docutils literal notranslate"><span class="pre">unit</span></code> as the argument type is to indicate to the
client that the argument value is not going to be used. After all, there’s
nothing interesting that the function can do with the unit value. Another way to
think about that would be that a function whose input type is <code class="docutils literal notranslate"><span class="pre">unit</span></code> is like a
function or method in an imperative language that takes in no arguments. For
example, in Java a linked list class could have a constructor that takes no
arguments and creates an empty list:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">LinkedList</span> <span class="p">{</span>
  <span class="cm">/** Returns an empty list. */</span>
  <span class="n">LinkedList</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Mutable values.</strong> In <code class="docutils literal notranslate"><span class="pre">mlist</span></code>, the nodes of the list are mutable, but the
values are not.  If we wanted the values also to be mutable, we can make
them refs too:</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span> <span class="o">=</span> <span class="o">{</span> <span class="n">next</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">;</span> <span class="k">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span> <span class="o">}</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span> <span class="n">ref</span>

<span class="k">let</span> <span class="n">empty</span> <span class="bp">()</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">insert_first</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>
  <span class="n">lst</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">!</span><span class="n">lst</span><span class="o">;</span> <span class="k">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">v</span> <span class="o">}</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">set</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">(!</span><span class="n">lst</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">invalid_arg</span> <span class="s2">&quot;out of bounds&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="k">value</span> <span class="o">},</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="k">value</span> <span class="o">:=</span> <span class="n">v</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span> <span class="o">},</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="n">next</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">v</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">to_list</span> <span class="o">(</span><span class="n">lst</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">mlist</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">match</span> <span class="o">!</span><span class="n">lst</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">{</span> <span class="n">next</span><span class="o">;</span> <span class="k">value</span> <span class="o">}</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="k">value</span> <span class="o">::</span> <span class="n">to_list</span> <span class="n">next</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a node = { next : &#39;a mlist; value : &#39;a ref; }
and &#39;a mlist = &#39;a node option ref
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val empty : unit -&gt; &#39;a mlist = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val insert_first : &#39;a mlist -&gt; &#39;a -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val set : &#39;a mlist -&gt; int -&gt; &#39;a -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val to_list : &#39;a mlist -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Now rather than having to create new nodes if we want to change a value,
we can directly mutate the value in a node:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">empty</span> <span class="bp">()</span><span class="o">;;</span>
<span class="n">insert_first</span> <span class="n">lst</span> <span class="mi">42</span><span class="o">;;</span>
<span class="n">insert_first</span> <span class="n">lst</span> <span class="mi">41</span><span class="o">;;</span>
<span class="n">to_list</span> <span class="n">lst</span><span class="o">;;</span>
<span class="n">set</span> <span class="n">lst</span> <span class="mi">1</span> <span class="mi">43</span><span class="o">;;</span>
<span class="n">to_list</span> <span class="n">lst</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val lst : &#39;_weak4 mlist = {contents = None}
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [41; 42]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int list = [41; 43]
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "cs3110/textbook",
            ref: "jupyter",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "ocaml-jupyter"
        },
        kernelOptions: {
            kernelName: "ocaml-jupyter",
            path: "./chapters/mut"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'ocaml-jupyter'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="intro.html" title="previous page"><span class="section-number">7. </span>Mutability</a>
    <a class='right-next' id="next-link" href="mutable_fields.html" title="next page"><span class="section-number">7.2. </span>Mutable Fields</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Michael R. Clarkson et al.<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>