

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>8.6. Promises &#8212; OCaml Programming: Correct + Efficient + Beautiful</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/ds/promises';</script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8.7. Monads" href="monads.html" />
    <link rel="prev" title="8.5. Memoization" href="memoization.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../cover.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/lambda-light.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/lambda-light.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../preface/about.html">About This Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface/install.html">Installing OCaml</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/intro.html">1. Better Programming Through OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/past.html">1.1. The Past of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/present.html">1.2. The Present of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/future.html">1.3. Look to Your Future</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/3110.html">1.4. A Brief History of CS 3110</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/summary.html">1.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../basics/intro.html">2. The Basics of OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../basics/toplevel.html">2.1. The OCaml Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/compiling.html">2.2. Compiling OCaml Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/expressions.html">2.3. Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/functions.html">2.4. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/documentation.html">2.5. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/printing.html">2.6. Printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/debugging.html">2.7. Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/summary.html">2.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/exercises.html">2.9. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">OCaml Programming</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../data/intro.html">3. Data and Types</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data/lists.html">3.1. Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/variants.html">3.2. Variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/ounit.html">3.3. Unit Testing with OUnit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/records_tuples.html">3.4. Records and Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/pattern_matching_advanced.html">3.5. Advanced Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/type_synonym.html">3.6. Type Synonyms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/options.html">3.7. Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/assoc_list.html">3.8. Association Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/algebraic_data_types.html">3.9. Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exceptions.html">3.10. Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/trees.html">3.11. Example: Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/nats.html">3.12. Example: Natural Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/summary.html">3.13. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exercises.html">3.14. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../hop/intro.html">4. Higher-Order Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../hop/higher_order.html">4.1. Higher-Order Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/map.html">4.2. Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/filter.html">4.3. Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/fold.html">4.4. Fold</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/beyond_lists.html">4.5. Beyond Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/pipelining.html">4.6. Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/currying.html">4.7. Currying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/summary.html">4.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/exercises.html">4.9. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../modules/intro.html">5. Modular Programming</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_systems.html">5.1. Module Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">5.2. Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/toplevel.html">5.3. Modules and the Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/encapsulation.html">5.4. Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/compilation_units.html">5.5. Compilation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functional_data_structures.html">5.6. Functional Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_type_constraints.html">5.7. Module Type Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/includes.html">5.8. Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functors.html">5.9. Functors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/summary.html">5.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/exercises.html">5.11. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Correctness and Efficiency</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../correctness/intro.html">6. Correctness</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../correctness/specifications.html">6.1. Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/function_docs.html">6.2. Function Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/module_docs.html">6.3. Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/test_debug.html">6.4. Testing and Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/black_glass_box.html">6.5. Black-box and Glass-box Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/randomized.html">6.6. Randomized Testing with QCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/proving_correctness.html">6.7. Proving Correctness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/structural_induction.html">6.8. Structural Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/alg_spec.html">6.9. Algebraic Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/summary.html">6.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/exercises.html">6.11. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mut/intro.html">7. Mutability</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mut/refs.html">7.1. Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/mutable_fields.html">7.2. Mutable Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/arrays.html">7.3. Arrays and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/summary.html">7.4. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/exercises.html">7.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">8. Data Structures</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hash_tables.html">8.1. Hash Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="amortized.html">8.2. Amortized Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="rb.html">8.3. Red-Black Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="sequence.html">8.4. Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="memoization.html">8.5. Memoization</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.6. Promises</a></li>
<li class="toctree-l2"><a class="reference internal" href="monads.html">8.7. Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">8.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="exercises.html">8.9. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Language Implementation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../interp/intro.html">9. Interpreters</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../interp/calculator.html">9.1. Example: Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/parsing.html">9.2. Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/substitution.html">9.3. Substitution Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/environment.html">9.4. Environment Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/typecheck.html">9.5. Type Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/inference.html">9.6. Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/summary.html">9.7. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/exercises.html">9.8. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lagniappe</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../adv/curry-howard.html">The Curry-Howard Correspondence</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix/bigoh.html">Big-Oh Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/vm.html">Virtual Machine</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/cs3110/textbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/edit/main/src/chapters/ds/promises.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/ds/promises.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chapters/ds/promises.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Promises</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#concurrency">8.6.1. Concurrency</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#threads">8.6.2. Threads</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">8.6.3. Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-our-own-promises">8.6.4. Making Our Own Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lwt-promises">8.6.5. Lwt Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#asynchronous-i-o">8.6.6. Asynchronous I/O</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#promises-and-asynchronous-i-o">8.6.7. Promises and Asynchronous I/O</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#callbacks">8.6.8. Callbacks</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implementing-callbacks">8.6.9. Implementing Callbacks</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-full-implementation">8.6.10. The Full Implementation</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="promises">
<h1><span class="section-number">8.6. </span>Promises<a class="headerlink" href="#promises" title="Permalink to this headline">#</a></h1>
<p>So far we have only considered <em>sequential</em> programs. Execution of a sequential
program proceeds one step at a time, with no choice about which step to take
next. Sequential programs are limited in that they are not very good at dealing
with multiple sources of simultaneous input and they can only execute on a
single processor. Many modern applications are instead <em>concurrent</em>.</p>
<section id="concurrency">
<h2><span class="section-number">8.6.1. </span>Concurrency<a class="headerlink" href="#concurrency" title="Permalink to this headline">#</a></h2>
<p>Concurrent programs enable computations to overlap in duration, instead of being
forced to happen sequentially.</p>
<ul class="simple">
<li><p><em>Graphical user interfaces</em> (GUIs), for example, rely on concurrency to keep
the interface responsive while computation continues in the background.
Without concurrency, a GUI would “lock up” until the current action is
completed. Sometimes, because of concurrency bugs, that happens
anyway—and it’s frustrating for the user!</p></li>
<li><p>A spreadsheet needs concurrency to re-compute all the cells while still
keeping the menus and editing capabilities available for the user.</p></li>
<li><p>A web browser needs concurrency to read and render web pages incrementally as
new data comes in over the network, to run JavaScript programs embedded in the
web page, and to enable the user to navigate through the page and click on
hyperlinks.</p></li>
</ul>
<p><em>Servers</em> are another example of applications that need concurrency. A web
server needs to respond to many requests from clients, and clients would prefer
not to wait. If an assignment is released in CMS, for example, you would prefer
to be able to view that assignment at the same time as everyone else in the
class, rather than having to “take a number” a wait for your number to be
called—as at the Department of Motor Vehicles, or at an old-fashioned
deli, etc.</p>
<p>One of the primary jobs of an <em>operating system</em> (OS) is to provide concurrency.
The OS makes it possible for many applications to be executing concurrently: a
music player, a web browser, a code editor, etc. How does it do that? There are
two fundamental, complementary approaches:</p>
<ul class="simple">
<li><p><strong>Interleaving:</strong> rapidly switch back and forth between computations. For
example, execute the music player for 100 milliseconds, then the browser, then
the editor, then repeat. That makes it appear as though multiple computations
are occurring simultaneously, but in reality, only one is ever occurring at
the same time.</p></li>
<li><p><strong>Parallelism:</strong> use hardware that is capable of performing two or more
computations literally at the same time. Many processors these days are
<em>multicore</em>, meaning that they have multiple central processing units (CPUs),
each of which can be executing a program simultaneously.</p></li>
</ul>
<p>Regardless of the approaches being used, concurrent programming is challenging.
Even if there are multiple cores available for simultaneous use, there are still
many other resources that must be shared: memory, the screen, the network
interface, etc. Managing that sharing, especially without introducing bugs, is
quite difficult. For example, if two programs want to communicate by using the
computer’s memory, there needs to be some agreement on when each program is
allowed to read and write from the memory. Otherwise, for example, both programs
might attempt to write to the same location in memory, leading to corrupted
data. Those kinds of <em>race conditions</em>, where a program races to complete its
operations before another program, are notoriously difficult to avoid.</p>
<p>The most fundamental challenge is that concurrency makes the execution of a
program become <em>nondeterministic:</em> the order in which operations occur cannot
necessarily be known ahead of time. Race conditions are an example of
nondeterminism. To program correctly in the face of nondeterminism, the
programmer is forced to think about <em>all</em> possible orders in which operations
might execute, and ensure that in <em>all</em> of them the program works correctly.</p>
<p>Purely functional programs make nondeterminism easier to reason about, because
evaluation of an expression always returns the same value no matter what. For
example, in the expression <code class="docutils literal notranslate"><span class="pre">(2</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">(3</span> <span class="pre">*</span> <span class="pre">5)</span></code>, the operations can be executed
concurrently (e.g., with the left and right products evaluated simultaneously)
without changing the answer. Imperative programming is more problematic. For
example, the expressions <code class="docutils literal notranslate"><span class="pre">!x</span></code> and <code class="docutils literal notranslate"><span class="pre">incr</span> <span class="pre">x;</span> <span class="pre">!x</span></code>, if executed concurrently, could
give different results depending on which executes first.</p>
</section>
<section id="threads">
<h2><span class="section-number">8.6.2. </span>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">#</a></h2>
<p>To make concurrent programming easier, computer scientists have invented many
abstractions. One of the best known is <em>threads</em>. Abstractly, a thread is a
single sequential computation. There can be many threads running at a time,
either interleaved or in parallel depending on the hardware, and a <em>scheduler</em>
handles choosing which threads are running at any given time. Scheduling can
either be <em>preemptive</em>, meaning that the scheduler is permitted to stop a thread
and restart it later without the thread getting a choice in the matter, or
<em>cooperative</em>, meaning that the thread must choose to relinquish control back to
the scheduler. The former can lead to race conditions, and the latter can lead
to unresponsive applications.</p>
<p>Concretely, a thread is a set of values that are loaded into the
registers of a processor.  Those values tell the processor where to find
the next instruction to execute, where its stack and heap are located in
memory, etc.  To implement preemption, a scheduler sets a timer in the
hardware; when the timer goes off, the current thread is interrupted and
the scheduler gets to run.  CS 3410 and 4410 cover those concepts in
detail.</p>
</section>
<section id="id1">
<h2><span class="section-number">8.6.3. </span>Promises<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h2>
<p>In the functional programming paradigm, one of the best known abstractions for
concurrency is <em>promises</em>. Other names for this idea include <em>futures</em>,
<em>deferreds</em>, and <em>delayeds</em>. All those names refer to the idea of a computation
that is not yet finished: it has promised to eventually produce a value in the
future, but the completion of the computation has been deferred or delayed.
There may be many such values being computed concurrently, and when the value is
finally available, there may be computations ready to execute that depend on the
value.</p>
<p>This idea has been widely adopted in many languages and libraries, including
Java, JavaScript, and .NET. Indeed, modern JavaScript adds an <code class="docutils literal notranslate"><span class="pre">async</span></code> keyword
that causes a function to return a promise, and an <code class="docutils literal notranslate"><span class="pre">await</span></code> keyword that waits
for a promise to finish computing. There are two widely-used libraries in OCaml
that implement promises: Async and Lwt. Async is developed by Jane Street. Lwt
is part of the Ocsigen project, which is a web framework for OCaml.</p>
<p>We now take a deeper look at promises in Lwt. The name of the library was an
acronym for “light-weight threads.” But that was a misnomer, as the
<a class="reference external" href="https://github.com/ocsigen/lwt">GitHub page</a> admits (as of 10/22/18):</p>
<blockquote>
<div><p>Much of the current manual refers to … “lightweight threads” or
just “threads.” This will be fixed in the new manual. [Lwt implements] promises,
and has nothing to do with system or preemptive threads.</p>
</div></blockquote>
<p>So don’t think of Lwt as having anything to do with threads: it really is a
library for promises.</p>
<p>In Lwt, a <em>promise</em> is a write-once reference: a value that is permitted to
mutate at most once. When created, it is like an empty box that contains
nothing. We say that the promise is <em>pending</em>. Eventually the promise can be
<em>resolved</em>, which is like putting something inside the box. Instead of being
resolved, the promise can instead be <em>rejected</em>, in which case the box is filled
with an exception. Regardless of whether the promise is resolved or rejected,
once the box is filled, its contents may never change.</p>
<p>For now, we will mostly forget about concurrency. Later we’ll come back and
incorporate it. But there is one part of the design for concurrency that we need
to address now. When we later start using functions for OS-provided concurrency,
such as concurrent reads and writes from files, there will need to be a division
of responsibilities:</p>
<ul class="simple">
<li><p>The client code that wants to make use of concurrency will need to <em>access</em>
promises: query whether they are resolved or pending, and make use of the
resolved values.</p></li>
<li><p>The library and OS code that implements concurrency will need to <em>mutate</em> the
promise—that is, to actually resolve or reject it. Client code does not
need that ability.</p></li>
</ul>
<p>We therefore will introduce one additional abstraction called a <em>resolver</em>.
There will be a one-to-one association between promises and resolvers. The
resolver for a promise will be used internally by the concurrency library but
not revealed to clients. The clients will only get access to the promise.</p>
<p>For example, suppose the concurrency library supported a operation to
concurrently read a string from the network. The library would implement that
operation as follows:</p>
<ul class="simple">
<li><p>Create a new promise and its associated resolver. The promise is pending.</p></li>
<li><p>Call an OS function that will concurrently read the string then invoke the
resolver on that string.</p></li>
<li><p>Return the promise (but not resolver) to the client. The OS meanwhile
continues to work on reading the string.</p></li>
</ul>
<p>You might think of the resolver as being a “private and writeable” value used
primarily by the library and the promise as being a “public and read-only” value
used primarily by the client.</p>
</section>
<section id="making-our-own-promises">
<h2><span class="section-number">8.6.4. </span>Making Our Own Promises<a class="headerlink" href="#making-our-own-promises" title="Permalink to this headline">#</a></h2>
<p>Here is an interface for our own Lwt-style promises. The names have been changed
to make the interface clearer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** A signature for Lwt-style promises, with better names *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nc">Pending</span>
    <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
    <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span>

  <span class="c">(** [make ()] is a new promise and resolver. The promise is pending. *)</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span>

  <span class="c">(** [return x] is a new promise that is already resolved with value</span>
<span class="c">      [x]. *)</span>
  <span class="k">val</span> <span class="n">return</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="c">(** [state p] is the state of the promise *)</span>
  <span class="k">val</span> <span class="n">state</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span>

  <span class="c">(** [resolve r x] resolves the promise [p] associated with [r] with</span>
<span class="c">      value [x], meaning that [state p] will become [Resolved x].</span>
<span class="c">      Requires: [p] is pending. *)</span>
  <span class="k">val</span> <span class="n">resolve</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(** [reject r x] rejects the promise [p] associated with [r] with</span>
<span class="c">      exception [x], meaning that [state p] will become [Rejected x].</span>
<span class="c">      Requires: [p] is pending. *)</span>
  <span class="k">val</span> <span class="n">reject</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">-&gt;</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>module type PROMISE =
  sig
    type &#39;a state = Pending | Resolved of &#39;a | Rejected of exn
    type &#39;a promise
    type &#39;a resolver
    val make : unit -&gt; &#39;a promise * &#39;a resolver
    val return : &#39;a -&gt; &#39;a promise
    val state : &#39;a promise -&gt; &#39;a state
    val resolve : &#39;a resolver -&gt; &#39;a -&gt; unit
    val reject : &#39;a resolver -&gt; exn -&gt; unit
  end
</pre></div>
</div>
</div>
</div>
<p>To implement that interface, we can make the representation type of
<code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">promise</span></code> be a reference to a state:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span> <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="n">ref</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a state = Pending | Resolved of &#39;a | Rejected of exn
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a promise = &#39;a state ref
</pre></div>
</div>
</div>
</div>
<p>That way it’s possible to mutate the contents of the promise.</p>
<p>For the representation type of the resolver, we’ll do something a little clever.
It will simply be the same as a promise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a resolver = &#39;a promise
</pre></div>
</div>
</div>
</div>
<p>So internally, the two types are exactly the same. But externally no client of
the <code class="docutils literal notranslate"><span class="pre">Promise</span></code> module will be able to distinguish them. In other words, we’re
using the type system to control whether it’s possible to apply certain
functions (e.g., <code class="docutils literal notranslate"><span class="pre">state</span></code> vs <code class="docutils literal notranslate"><span class="pre">resolve</span></code>) to a promise.</p>
<p>To help implement the rest of the functions, let’s start by writing a helper
function <code class="docutils literal notranslate"><span class="pre">update</span> <span class="pre">:</span> <span class="pre">'a</span> <span class="pre">promise</span> <span class="pre">-&gt;</span> <span class="pre">'a</span> <span class="pre">state</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code> to update the reference. This
function will implement changing the state of the promise from pending to either
resolved or rejected, and once the state has changed, it will not allow it to be
changed again. In other words, <code class="docutils literal notranslate"><span class="pre">update</span></code> enforces the “write once” invariant.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [write_once p s] changes the state of [p] to be [s].  If [p] and [s]</span>
<span class="c">    are both pending, that has no effect.</span>
<span class="c">    Raises: [Invalid_arg] if the state of [p] is not pending. *)</span>
<span class="k">let</span> <span class="n">write_once</span> <span class="n">p</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">p</span> <span class="o">=</span> <span class="nc">Pending</span>
  <span class="k">then</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">s</span>
  <span class="k">else</span> <span class="n">invalid_arg</span> <span class="s2">&quot;cannot write twice&quot;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val write_once : &#39;a state ref -&gt; &#39;a state -&gt; unit = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Using that helper, we can implement the <code class="docutils literal notranslate"><span class="pre">make</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">Pending</span> <span class="k">in</span>
  <span class="n">p</span><span class="o">,</span> <span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val make : unit -&gt; &#39;a state ref * &#39;a state ref = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>The remaining functions in the interface are trivial to implement.
Putting it altogether in a module, we have:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">Promise</span> <span class="o">:</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nc">Pending</span>
    <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
    <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="n">ref</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="c">(** [write_once p s] changes the state of [p] to be [s]. If [p] and</span>
<span class="c">      [s] are both pending, that has no effect. Raises: [Invalid_arg] if</span>
<span class="c">      the state of [p] is not pending. *)</span>
  <span class="k">let</span> <span class="n">write_once</span> <span class="n">p</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">p</span> <span class="o">=</span> <span class="nc">Pending</span> <span class="k">then</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">s</span> <span class="k">else</span> <span class="n">invalid_arg</span> <span class="s2">&quot;cannot write twice&quot;</span>

  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">Pending</span> <span class="k">in</span>
    <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">return</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">(</span><span class="nc">Resolved</span> <span class="n">x</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">state</span> <span class="n">p</span> <span class="o">=</span> <span class="o">!</span><span class="n">p</span>

  <span class="k">let</span> <span class="n">resolve</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span> <span class="n">write_once</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Resolved</span> <span class="n">x</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">reject</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span> <span class="n">write_once</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Rejected</span> <span class="n">x</span><span class="o">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>module Promise : PROMISE
</pre></div>
</div>
</div>
</div>
</section>
<section id="lwt-promises">
<h2><span class="section-number">8.6.5. </span>Lwt Promises<a class="headerlink" href="#lwt-promises" title="Permalink to this headline">#</a></h2>
<p>The types and names used in Lwt are a bit more obscure than those we used above.
Lwt uses analogical terminology that comes from threads—but since Lwt does
not actually implement threads, that terminology is not necessarily helpful. (We
don’t mean to demean Lwt! It is a library that has been developing and changing
over time.)</p>
<p>The Lwt interface includes the following declarations, which we have annotated
with comments to compare them to the interface we implemented above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">type</span> <span class="nc">Lwt</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* [Sleep] means pending.  [Return] means resolved.</span>
<span class="c">     [Fail] means rejected. *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span> <span class="nc">Sleep</span> <span class="o">|</span> <span class="nc">Return</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Fail</span> <span class="k">of</span> <span class="n">exn</span>

  <span class="c">(* a [t] is a promise *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>

  <span class="c">(* a [u] is a resolver *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">u</span>

  <span class="k">val</span> <span class="n">state</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span>

  <span class="c">(* [wakeup] means [resolve] *)</span>
  <span class="k">val</span> <span class="n">wakeup</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">u</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(* [wakeup_exn] means [reject] *)</span>
  <span class="k">val</span> <span class="n">wakeup_exn</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(* [wait] means [make] *)</span>
  <span class="k">val</span> <span class="n">wait</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">u</span>

  <span class="k">val</span> <span class="n">return</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>module type Lwt =
  sig
    type &#39;a state = Sleep | Return of &#39;a | Fail of exn
    type &#39;a t
    type &#39;a u
    val state : &#39;a t -&gt; &#39;a state
    val wakeup : &#39;a u -&gt; &#39;a -&gt; unit
    val wakeup_exn : &#39;a u -&gt; exn -&gt; unit
    val wait : unit -&gt; &#39;a t * &#39;a u
    val return : &#39;a -&gt; &#39;a t
  end
</pre></div>
</div>
</div>
</div>
<p>Lwt’s implementation of that interface is much more complex than our own
implementation above, because Lwt actually supports many more operations on
promises. Nonetheless, the core ideas that we developed above provide sound
intuition for what Lwt implements.</p>
<p>Here is some example Lwt code that you can try out in utop:</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span><span class="n">require</span> <span class="s2">&quot;lwt&quot;</span><span class="o">;;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">p</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">wait</span><span class="bp">()</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val p : &#39;_weak1 Lwt.t = &lt;abstr&gt;
val r : &#39;_weak1 Lwt.u = &lt;abstr&gt;
</pre></div>
</div>
</div>
</div>
<p>To avoid those weak type variables, we can provide a further hint to OCaml as to
what type we want to eventually put into the promise. For example, if we wanted
to have a promise that will eventually contain an <code class="docutils literal notranslate"><span class="pre">int</span></code>, we could write this
code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">t</span><span class="o">),</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">wait</span> <span class="bp">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val p : int Lwt.t = &lt;abstr&gt;
val r : int Lwt.u = &lt;abstr&gt;
</pre></div>
</div>
</div>
</div>
<p>Now we can resolve the promise:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">state</span> <span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int Lwt.state = Lwt.Sleep
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">wakeup</span> <span class="n">r</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">state</span> <span class="n">p</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int Lwt.state = Lwt.Return 42
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">wakeup</span> <span class="n">r</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="ne">Exception</span>: Invalid_argument &quot;Lwt.wakeup&quot;.
<span class="n">Raised</span> <span class="n">at</span> <span class="n">Stdlib</span><span class="o">.</span><span class="n">invalid_arg</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;stdlib.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">30</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">20</span><span class="o">-</span><span class="mi">45</span>
<span class="n">Called</span> <span class="kn">from</span> <span class="nn">Stdlib__Fun.protect</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;fun.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">33</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">8</span><span class="o">-</span><span class="mi">15</span>
<span class="n">Re</span><span class="o">-</span><span class="n">raised</span> <span class="n">at</span> <span class="n">Stdlib__Fun</span><span class="o">.</span><span class="n">protect</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;fun.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">38</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">6</span><span class="o">-</span><span class="mi">52</span>
<span class="n">Called</span> <span class="kn">from</span> <span class="nn">Topeval.load_lambda</span> <span class="ow">in</span> <span class="n">file</span> <span class="s2">&quot;toplevel/byte/topeval.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">89</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">4</span><span class="o">-</span><span class="mi">150</span>
</pre></div>
</div>
</div>
</div>
<p>That last exception was raised because we attempted to resolve the promise a
second time, which is not permitted.</p>
<p>To reject a promise, we can write similar code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">t</span><span class="o">),</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">wait</span> <span class="bp">()</span><span class="o">;;</span>
<span class="nn">Lwt</span><span class="p">.</span><span class="n">wakeup_exn</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;nope&quot;</span><span class="o">);;</span>
<span class="nn">Lwt</span><span class="p">.</span><span class="n">state</span> <span class="n">p</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val p : int Lwt.t = &lt;abstr&gt;
val r : int Lwt.u = &lt;abstr&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : unit = ()
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int Lwt.state = Lwt.Fail (Failure &quot;nope&quot;)
</pre></div>
</div>
</div>
</div>
<p>Note that nothing we have implemented so far does anything concurrently.
The promise abstraction by itself is not inherently concurrent.  It’s
just a data structure that can be written at most once, and that provides
a means to control who can write to it (through the resolver).</p>
</section>
<section id="asynchronous-i-o">
<h2><span class="section-number">8.6.6. </span>Asynchronous I/O<a class="headerlink" href="#asynchronous-i-o" title="Permalink to this headline">#</a></h2>
<p>Now that we understand promises as a data abstraction, let’s turn to how they
can be used for concurrency. The typical way they’re used with Lwt is for
concurrent input and output (I/O).</p>
<p>The I/O functions that are part of the OCaml standard library are <em>synchronous</em>
aka <em>blocking</em>: when you call such a function, it does not return until the I/O
has been completed. “Synchronous” here refers to the synchronization between
your code and the I/O function: your code does not get to execute again until
the I/O code is done. “Blocking” refers to the fact that your code has to
wait—it is blocked—until the I/O completes.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">Stdlib.input_line</span> <span class="pre">:</span> <span class="pre">in_channel</span> <span class="pre">-&gt;</span> <span class="pre">string</span></code> function reads
characters from an <em>input channel</em> until it reaches a newline character, then
returns the characters it read. The type <code class="docutils literal notranslate"><span class="pre">in_channel</span></code> is abstract; it represents
a source of data that can be read, such as a file, or the network, or the
keyboard. The value <code class="docutils literal notranslate"><span class="pre">Stdlib.stdin</span> <span class="pre">:</span> <span class="pre">in_channel</span></code> represents the <em>standard input</em>
channel, which is the channel which usually, by default, provides keyboard
input.</p>
<p>If you run the following code in utop, you will observe the blocking behavior:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># ignore(input_line stdin); print_endline &quot;done&quot;;;
&lt;type your own input here&gt;
done
- : unit = ()
</pre></div>
</div>
<p>The string <code class="docutils literal notranslate"><span class="pre">&quot;done&quot;</span></code> is not printed until after the input operation completes,
which happens after you type Enter.</p>
<p>Synchronous I/O makes it impossible for a program to carry on other computations
while it is waiting for the I/O operation to complete. For some programs that’s
just fine. A text adventure game, for example, doesn’t have any background
computations it needs to perform. But other programs, like spreadsheets or
servers, would be improved by being able to carry on computations in the
background rather than having to completely block while waiting for input.</p>
<p><em>Asynchronous</em> aka <em>non-blocking</em> I/O is the opposite style of I/O. Asynchronous
I/O operations return immediately, regardless of whether the input or output has
been completed. That enables a program to launch an I/O operation, carry on
doing other computations, and later come back to make use of the completed
operation.</p>
<p>The Lwt library provides its own I/O functions in the <code class="docutils literal notranslate"><span class="pre">Lwt_io</span></code> module, which is
in the <code class="docutils literal notranslate"><span class="pre">lwt.unix</span></code> package. The function
<code class="docutils literal notranslate"><span class="pre">Lwt_io.read_line</span> <span class="pre">:</span> <span class="pre">Lwt_io.input_channel</span> <span class="pre">-&gt;</span> <span class="pre">string</span> <span class="pre">Lwt.t</span></code> is the asynchronous
equivalent of <code class="docutils literal notranslate"><span class="pre">Stdlib.input_line</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">Lwt_io.input_channel</span></code> is the
equivalent of the OCaml standard library’s <code class="docutils literal notranslate"><span class="pre">in_channel</span></code>, and <code class="docutils literal notranslate"><span class="pre">Lwt_io.stdin</span></code>
represents the standard input channel.</p>
<p>Run this code in utop to observe the non-blocking behavior:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># #require &quot;lwt.unix&quot;;;
# open Lwt_io;;
# ignore(read_line stdin); printl &quot;done&quot;;;
done
- : unit = ()
# &lt;type your own input here&gt;
</pre></div>
</div>
<p>The string <code class="docutils literal notranslate"><span class="pre">&quot;done&quot;</span></code> is printed immediately by <code class="docutils literal notranslate"><span class="pre">Lwt_io.printl</span></code>, which is Lwt’s
equivalent of <code class="docutils literal notranslate"><span class="pre">Stdlib.print_endline</span></code>, before you even type. Note that it’s best
to use just one library’s I/O functions, rather than mix them together.</p>
<p>When you do type your input, you don’t see it echoed to the screen, because it’s
happening in the background. Utop is still executing—it is not
blocked—but your input is being sent to that <code class="docutils literal notranslate"><span class="pre">read_line</span></code> function instead
of to utop. When you finally type Enter, the input operation completes, and you
are back to interacting with utop.</p>
<p>Now imagine that instead of reading a line asynchronously, the program was a web
server reading a file to be served to a client. And instead of printing a
string, the server was delivering the contents of a different file that had
completed reading to a different client. That’s why asynchronous I/O can be so
useful: it helps to <em>hide latency</em>. Here, “latency” means waiting for data to be
transferred from one place to another, e.g., from disk to memory. Latency hiding
is an excellent use for concurrency.</p>
<p>Note that all the concurrency here is really coming from the operating system,
which is what provides the underlying asynchronous I/O infrastructure. Lwt is
just exposing that infrastructure to you through a library.</p>
</section>
<section id="promises-and-asynchronous-i-o">
<h2><span class="section-number">8.6.7. </span>Promises and Asynchronous I/O<a class="headerlink" href="#promises-and-asynchronous-i-o" title="Permalink to this headline">#</a></h2>
<p>The output type of <code class="docutils literal notranslate"><span class="pre">Lwt_io.read_line</span></code> is <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Lwt.t</span></code>, meaning that the
function returns a <code class="docutils literal notranslate"><span class="pre">string</span></code> promise. Let’s investigate how the state of that
promise evolves.</p>
<p>When the promise is returned from <code class="docutils literal notranslate"><span class="pre">read_line</span></code>, it is pending:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let p = read_line stdin in Lwt.state p;;
- : string Lwt.state = Lwt.Sleep
# &lt;now you have to type input and Enter to regain control of utop&gt;
</pre></div>
</div>
<p>When the Enter key is pressed and input is completed, the promise returned from
<code class="docutils literal notranslate"><span class="pre">read_line</span></code> should become resolved. For example, suppose you enter “Camels are
bae”:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let p = read_line stdin;;
val p : string Lwt.t = &lt;abstr&gt;
&lt;now you type Camels are bae followed by Enter&gt;
# p;;
- : string = &quot;Camels are bae&quot;
</pre></div>
</div>
<p>But, if you study that output carefully, you’ll notice something very strange
just happened! After the <code class="docutils literal notranslate"><span class="pre">let</span></code> statement, <code class="docutils literal notranslate"><span class="pre">p</span></code> had type <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Lwt.t</span></code>, as
expected. But when we evaluated <code class="docutils literal notranslate"><span class="pre">p</span></code>, it came back as type <code class="docutils literal notranslate"><span class="pre">string</span></code>. It’s as if
the promise disappeared.</p>
<p>What’s actually happening is that utop has some special—and potentially
confusing—functionality built into it that is related to Lwt.
Specifically, whenever you try to directly evaluate a promise at the top level,
<em>utop will give you the contents of the promise, rather than the promise itself,
and if the promise is not yet resolved, utop will block until the promise
becomes resolved so that the contents can be returned.</em></p>
<p>So the output <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">=</span> <span class="pre">&quot;Camels</span> <span class="pre">are</span> <span class="pre">bae&quot;</span></code> really means that <code class="docutils literal notranslate"><span class="pre">p</span></code> contains a
resolved <code class="docutils literal notranslate"><span class="pre">string</span></code> whose value is <code class="docutils literal notranslate"><span class="pre">&quot;Camels</span> <span class="pre">are</span> <span class="pre">bae&quot;</span></code>, not that <code class="docutils literal notranslate"><span class="pre">p</span></code> itself is a
<code class="docutils literal notranslate"><span class="pre">string</span></code>. Indeed, the <code class="docutils literal notranslate"><span class="pre">#show_val</span></code> directive will show us that <code class="docutils literal notranslate"><span class="pre">p</span></code> is a promise:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># #show_val p;;
val p : string Lwt.t
</pre></div>
</div>
<p>To disable that feature of utop, or to re-enable it, call the function
<code class="docutils literal notranslate"><span class="pre">UTop.set_auto_run_lwt</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">unit</span></code>, which changes how utop evaluates Lwt
promises at the top level. You can see the behavior change in the following
code:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># UTop.set_auto_run_lwt false;;
- : unit = ()
&lt;now you type Camels are bae followed by Enter&gt;
# p;;
- : string Lwt.state = &lt;abstr&gt;
# Lwt.state p;;
- : string Lwt.state = Lwt.Return &quot;Camels are bae&quot;
</pre></div>
</div>
<p>If you re-enable this “auto run” feature, and directly try to evaluate the
promise returned by <code class="docutils literal notranslate"><span class="pre">read_line</span></code>, you’ll see that it behaves exactly like
synchronous I/O, i.e., <code class="docutils literal notranslate"><span class="pre">Stdlib.input_line</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># UTop.set_auto_run_lwt true;;
- : unit = ()
# read_line stdin;;
Camels are bae
- : string = &quot;Camels are bae&quot;
</pre></div>
</div>
<p>Because of the potential confusion, we will henceforth assume that auto running
is disabled. A good way to make that happen is to put the following line in your
<code class="docutils literal notranslate"><span class="pre">.ocamlinit</span></code> file:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>UTop.set_auto_run_lwt false;;
</pre></div>
</div>
</section>
<section id="callbacks">
<h2><span class="section-number">8.6.8. </span>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">#</a></h2>
<p>For a program to benefit from the concurrency provided by asynchronous
I/O and promises, there needs to be a way for the program to make use of
resolved promises.  For example, if a web server is asynchronously
reading and serving multiple files to multiple clients, the server needs
a way to (i) become aware that a read has completed, and (ii) then do a
new asynchronous write with the result of the read. In other words,
programs need a mechanism for managing the dependencies among promises.</p>
<p>The mechanism provided in Lwt is named <em>callbacks.</em>  A callback is a
function that will be run sometime after a promise has been resolved,
and it will receive as input the contents of the resolved promise.
Think of it like asking your friend to do some work for you: they
promise to do it, and to call you back on the phone with the result of
the work sometime after they’ve finished.</p>
<p><strong>Registering a callback.</strong> Here is a function that prints a string using Lwt’s
version of the <code class="docutils literal notranslate"><span class="pre">printf</span></code> function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">print_the_string</span> <span class="n">str</span> <span class="o">=</span> <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;The string is: %S</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">str</span>
</pre></div>
</div>
<p>And here, repeated from the previous section, is our code that returns a promise
for a string read from standard input:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">read_line</span> <span class="n">stdin</span>
</pre></div>
</div>
<p>To register the printing function as a callback for that promise, we use the
function <code class="docutils literal notranslate"><span class="pre">Lwt.bind</span></code>, which <em>binds</em> the callback to the promise:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="n">p</span> <span class="n">print_the_string</span>
</pre></div>
</div>
<p>Sometime after <code class="docutils literal notranslate"><span class="pre">p</span></code> is resolved, hence contains a string, the callback function
will be run with that string as its input. That causes the string to be printed.</p>
<p>Here’s a complete utop transcript as an example of that:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let print_the_string str = Lwt_io.printf &quot;The string is: %S\n&quot; str;;
val print_the_string : string -&gt; unit Lwt.t = &lt;fun&gt;
# let p = read_line stdin in Lwt.bind p print_the_string;;
- : unit Lwt.t = &lt;abstr&gt;
  &lt;type Camels are bae followed by Enter&gt;
# The string is: &quot;Camels are bae&quot;
</pre></div>
</div>
<p><strong>Bind.</strong> The type of <code class="docutils literal notranslate"><span class="pre">Lwt.bind</span></code> is important to understand:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">&#39;</span><span class="n">a</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="nn">Lwt</span><span class="p">.</span><span class="n">t</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">bind</span></code> function takes a promise as its first argument. It doesn’t matter
whether that promise has been resolved yet or not. As its second argument,
<code class="docutils literal notranslate"><span class="pre">bind</span></code> takes a callback function. That callback takes an input which is the same
type <code class="docutils literal notranslate"><span class="pre">'a</span></code> as the contents of the promise. It’s not an accident that they have
the same type: the whole idea is to eventually run the callback on the resolved
promise, so the type the promise contains needs to be the same as the type the
callback expects as input.</p>
<p>After being invoked on a promise and callback, e.g., <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">p</span> <span class="pre">c</span></code>, the <code class="docutils literal notranslate"><span class="pre">bind</span></code>
function does one of three things, depending on the state of <code class="docutils literal notranslate"><span class="pre">p</span></code>:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is already resolved, then <code class="docutils literal notranslate"><span class="pre">c</span></code> is run immediately on the contents of
<code class="docutils literal notranslate"><span class="pre">p</span></code>. The promise that is returned might or might not be pending, depending on
what <code class="docutils literal notranslate"><span class="pre">c</span></code> does.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is already rejected, then <code class="docutils literal notranslate"><span class="pre">c</span></code> does not run. The promise that is
returned is also rejected, with the same exception as <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is pending, then <code class="docutils literal notranslate"><span class="pre">bind</span></code> does not wait for <code class="docutils literal notranslate"><span class="pre">p</span></code> to be resolved, nor for
<code class="docutils literal notranslate"><span class="pre">c</span></code> to be run. Rather, <code class="docutils literal notranslate"><span class="pre">bind</span></code> just registers the callback to eventually be run
when (or if) the promise is resolved. Therefore the <code class="docutils literal notranslate"><span class="pre">bind</span></code> function returns a
new promise. That promise will become resolved when (or if) the callback
completes running, sometime in the future. Its contents will be whatever
contents are contained within the promise that the callback itself returns.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the first case above: The Lwt source code claims that this behavior might
change in a later version: under high load, <code class="docutils literal notranslate"><span class="pre">c</span></code> might be registered to run
later. But as of v4.1.0 that behavior has not yet been activated. So, don’t
worry about it—this paragraph is just here to future-proof this
discussion.</p>
</div>
<p>Let’s consider that final case in more detail. We have one promise of type
<code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">Lwt.t</span></code> and two promises of type <code class="docutils literal notranslate"><span class="pre">'b</span> <span class="pre">Lwt.t</span></code>:</p>
<ul class="simple">
<li><p>The promise of type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">Lwt.t</span></code>, call it promise X, is an input to <code class="docutils literal notranslate"><span class="pre">bind</span></code>. It
was pending when <code class="docutils literal notranslate"><span class="pre">bind</span></code> was called, and when <code class="docutils literal notranslate"><span class="pre">bind</span></code> returns.</p></li>
<li><p>The first promise of type <code class="docutils literal notranslate"><span class="pre">'b</span> <span class="pre">Lwt.t</span></code>, call it promise Y, is created by <code class="docutils literal notranslate"><span class="pre">bind</span></code>
and returned to the user. It is pending at that point.</p></li>
<li><p>The second promise of type <code class="docutils literal notranslate"><span class="pre">'b</span> <span class="pre">Lwt.t</span></code>, call it promise Z, has not yet been
created. It will be created later, when promise X has been resolved, and the
callback has been run on the contents of X. The callback then returns promise
Z. There is no guarantee about the state of Z; it might well still be pending
when returned by the callback.</p></li>
<li><p>When Z is finally resolved, the contents of Y are updated to be the same as
the contents of Z.</p></li>
</ul>
<p>The reason why <code class="docutils literal notranslate"><span class="pre">bind</span></code> is designed with this type is so that programmers can set
up a <em>sequential chain</em> of callbacks. For example, the following code
asynchronously reads one string; then when that string has been read, proceeds
to asynchronously read a second string; then prints the concatenation of both
strings:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="o">(</span><span class="n">read_line</span> <span class="n">stdin</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s1</span> <span class="o">-&gt;</span>
  <span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="o">(</span><span class="n">read_line</span> <span class="n">stdin</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s2</span> <span class="o">-&gt;</span>
    <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s1</span><span class="o">^</span><span class="n">s2</span><span class="o">)));;</span>
</pre></div>
</div>
<p>If you run that in utop, something slightly confusing will happen again: after
you press Enter at the end of the first string, Lwt will allow utop to read one
character. The problem is that we’re mixing Lwt input operations with utop input
operations. It would be better to just create a program and run it from the
command line.</p>
<p>To do that, put the following code in a file called <code class="docutils literal notranslate"><span class="pre">read2.ml</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Lwt_io</span>

<span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="o">(</span><span class="n">read_line</span> <span class="n">stdin</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s1</span> <span class="o">-&gt;</span>
    <span class="nn">Lwt</span><span class="p">.</span><span class="n">bind</span> <span class="o">(</span><span class="n">read_line</span> <span class="n">stdin</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s2</span> <span class="o">-&gt;</span>
      <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s1</span><span class="o">^</span><span class="n">s2</span><span class="o">)))</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt_main</span><span class="p">.</span><span class="n">run</span> <span class="n">p</span>
</pre></div>
</div>
<p>We’ve added one new function: <code class="docutils literal notranslate"><span class="pre">Lwt_main.run</span> <span class="pre">:</span> <span class="pre">'a</span> <span class="pre">Lwt.t</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code>. It waits for its
input promise to be resolved, then returns the contents. Typically this function
is called only once in an entire program, near the end of the main file; and the
input to it is typically a promise whose resolution indicates that all execution
is finished.</p>
<p>Create a dune file:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(executable
 (name read2)
 (libraries lwt.unix))
</pre></div>
</div>
<p>And run the program, entering a couple strings:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">dune exec ./read2.exe</span>
<span class="go">My first string</span>
<span class="go">My second string</span>
<span class="go">My first stringMy second string</span>
</pre></div>
</div>
<p>Now try removing the last line of <code class="docutils literal notranslate"><span class="pre">read2.ml</span></code>.  You’ll see that the program
exits immediately, without waiting for you to type.</p>
<p><strong>Bind as an Operator.</strong> There is another syntax for bind that is used far more
frequently than what we have seen so far. The <code class="docutils literal notranslate"><span class="pre">Lwt.Infix</span></code> module defines an
infix operator written <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> that is the same as <code class="docutils literal notranslate"><span class="pre">bind</span></code>. That is, instead of
writing <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">p</span> <span class="pre">c</span></code> you write <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&gt;&gt;=</span> <span class="pre">c</span></code>. This operator makes it much easier to
write code without all the extra parentheses and indentations that our previous
example had:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Lwt_io</span>
<span class="k">open</span> <span class="nn">Lwt</span><span class="p">.</span><span class="nc">Infix</span>

<span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="n">read_line</span> <span class="n">stdin</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">s1</span> <span class="o">-&gt;</span>
  <span class="n">read_line</span> <span class="n">stdin</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">s2</span> <span class="o">-&gt;</span>
  <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s1</span><span class="o">^</span><span class="n">s2</span><span class="o">)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt_main</span><span class="p">.</span><span class="n">run</span> <span class="n">p</span>
</pre></div>
</div>
<p>The way to visually parse the definition of <code class="docutils literal notranslate"><span class="pre">p</span></code> is to look at each line as
computing some promised value. The first line, <code class="docutils literal notranslate"><span class="pre">read_line</span> <span class="pre">stdin</span> <span class="pre">&gt;&gt;=</span> <span class="pre">fun</span> <span class="pre">s1</span> <span class="pre">-&gt;</span></code>
means that a promise is created, resolved, and its contents extracted under the
name <code class="docutils literal notranslate"><span class="pre">s1</span></code>. The second line means the same, except that its contents are named
<code class="docutils literal notranslate"><span class="pre">s2</span></code>. The third line creates a final promise whose contents are eventually
extracted by <code class="docutils literal notranslate"><span class="pre">Lwt_main.run</span></code>, at which point the program may terminate.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> operator is perhaps most famous from the functional language Haskell,
which uses it extensively for monads. We’ll cover monads as our next major
topic.</p>
<p><strong>Bind as Let Syntax.</strong> There is a <em>syntax extension</em> for OCaml that makes using
bind even simpler than the infix operator <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>. To install the syntax
extension, run the following command:</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">opam</span> <span class="pre">install</span> <span class="pre">lwt_ppx</span></code></p>
<p>(You might need to <code class="docutils literal notranslate"><span class="pre">opam</span> <span class="pre">update</span></code> followed by <code class="docutils literal notranslate"><span class="pre">opam</span> <span class="pre">upgrade</span></code> first.)</p>
<p>With that extension, you can use a specialized <code class="docutils literal notranslate"><span class="pre">let</span></code> expression written
<code class="docutils literal notranslate"><span class="pre">let%lwt</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">e1</span> <span class="pre">in</span> <span class="pre">e2</span></code>, which is equivalent to <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">e1</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e2)</span></code> or
<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&gt;&gt;=</span> <span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e2</span></code>. We can rewrite our running example as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* to compile, add lwt_ppx to the libraries in the dune file *)</span>
<span class="k">open</span> <span class="nc">Lwt_io</span>

<span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="k">let</span><span class="o">%</span><span class="n">lwt</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">read_line</span> <span class="n">stdin</span> <span class="k">in</span>
  <span class="k">let</span><span class="o">%</span><span class="n">lwt</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">read_line</span> <span class="n">stdin</span> <span class="k">in</span>
  <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s1</span><span class="o">^</span><span class="n">s2</span><span class="o">)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt_main</span><span class="p">.</span><span class="n">run</span> <span class="n">p</span>
</pre></div>
</div>
<p>Now the code looks pretty much exactly like what its equivalent synchronous
version would be. But don’t be fooled: all the asynchronous I/O, the promises,
and the callbacks are still there. Thus, the evaluation of <code class="docutils literal notranslate"><span class="pre">p</span></code> first registers a
callback with a promise, then moves on to the the evaluation of <code class="docutils literal notranslate"><span class="pre">Lwt_main.run</span></code>
without waiting for the first string to finish being read. To prove that to
yourself, run the following code:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Lwt_io</span>

<span class="k">let</span> <span class="n">p</span> <span class="o">=</span>
  <span class="k">let</span><span class="o">%</span><span class="n">lwt</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">read_line</span> <span class="n">stdin</span> <span class="k">in</span>
  <span class="k">let</span><span class="o">%</span><span class="n">lwt</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">read_line</span> <span class="n">stdin</span> <span class="k">in</span>
  <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s1</span><span class="o">^</span><span class="n">s2</span><span class="o">)</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt_io</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;Got here first</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Lwt_main</span><span class="p">.</span><span class="n">run</span> <span class="n">p</span>
</pre></div>
</div>
<p>You’ll see that “Got here first” prints before you get a chance to enter any
input.</p>
<p><strong>Concurrent Composition.</strong> The <code class="docutils literal notranslate"><span class="pre">Lwt.bind</span></code> function provides a way to
sequentially compose callbacks: first one callback is run, then another, then
another, and so forth. There are other functions in the library for composition
of many callbacks as a set. For example,</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Lwt.join</span> <span class="pre">:</span> <span class="pre">unit</span> <span class="pre">Lwt.t</span> <span class="pre">list</span> <span class="pre">-&gt;</span> <span class="pre">unit</span> <span class="pre">Lwt.t</span></code> enables waiting upon multiple
promises. <code class="docutils literal notranslate"><span class="pre">Lwt.join</span> <span class="pre">ps</span></code> returns a promise that is pending until all the
promises in <code class="docutils literal notranslate"><span class="pre">ps</span></code> become resolved. You might register a callback on the return
promise from the <code class="docutils literal notranslate"><span class="pre">join</span></code> to take care of some computation that needs <strong>all</strong> of
a set of promises to be finished.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lwt.pick</span> <span class="pre">:</span> <span class="pre">'a</span> <span class="pre">Lwt.t</span> <span class="pre">list</span> <span class="pre">-&gt;</span> <span class="pre">'a</span> <span class="pre">Lwt.t</span></code> also enables waiting upon multiple
promises, but <code class="docutils literal notranslate"><span class="pre">Lwt.pick</span> <span class="pre">ps</span></code> returns a promise that is pending until at least
one promise in <code class="docutils literal notranslate"><span class="pre">ps</span></code> becomes resolved. You might register a callback on the
return promise from the <code class="docutils literal notranslate"><span class="pre">pick</span></code> to take care of some computation that needs
just one of a set of promises to be finished, but doesn’t care which one.</p></li>
</ul>
</section>
<section id="implementing-callbacks">
<h2><span class="section-number">8.6.9. </span>Implementing Callbacks<a class="headerlink" href="#implementing-callbacks" title="Permalink to this headline">#</a></h2>
<p>When a callback is registered with <code class="docutils literal notranslate"><span class="pre">bind</span></code> or one of the other syntaxes, it is
added to a list of callbacks that is stored with the promise. Eventually, when
the promise has been resolved, the Lwt <em>resolution loop</em> runs the callbacks
registered for the promise. There is no guarantee about the execution order of
callbacks for a promise. In other words, the execution order is
nondeterministic. If the order matters, the programmer needs to use the
composition operators (such as <code class="docutils literal notranslate"><span class="pre">bind</span></code> and <code class="docutils literal notranslate"><span class="pre">join</span></code>) to enforce an ordering. If the
promise never becomes resolved (or is rejected), none of its callbacks will ever
be run.</p>
<p>Once again, it’s important to keep track of where the concurrency really comes
from: the OS. There might be many asynchronous I/O operations occurring at the
OS level. But at the OCaml level, the resolution loop is sequential, meaning
that only one callback can ever be running at a time.</p>
<p>Finally, the resolution loop never attempts to interrupt a callback. So if the
callback goes into an infinite loop, no other callback will ever get to run.
That makes Lwt a cooperative concurrency mechanism, rather than preemptive.</p>
<p>To better understand callback resolution, let’s implement it ourselves. We’ll
use the <code class="docutils literal notranslate"><span class="pre">Promise</span></code> data structure we developed earlier. To start, we add a bind
operator to the <code class="docutils literal notranslate"><span class="pre">Promise</span></code> signature:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="k">type</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="o">...</span>

  <span class="c">(** [p &gt;&gt;= c] registers callback [c] with promise [p].</span>
<span class="c">      When the promise is resolved, the callback will be run</span>
<span class="c">      on the promises&#39;s contents.  If the promise is never</span>
<span class="c">      resolved, the callback will never run. *)</span>
  <span class="k">val</span> <span class="o">(&gt;&gt;=)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Next, let’s re-develop the entire <code class="docutils literal notranslate"><span class="pre">Promise</span></code> structure.  We start
off just like before:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">Promise</span> <span class="o">:</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span> <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>But now to implement the representation type of promises, we use a record with
mutable fields. The first field is the state of the promise, and it corresponds
to the <code class="docutils literal notranslate"><span class="pre">ref</span></code> we used before. The second field is more interesting and is
discussed below.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="c">(** RI: the input may not be [Pending] *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(** RI: if [state &lt;&gt; Pending] then [handlers = []]. *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">mutable</span> <span class="n">state</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">handlers</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span> <span class="kt">list</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>A <em>handler</em> is a new abstraction: a function that takes a non-pending state. It
will be used to handle resolving and rejecting promises when their state is
ready to switch away from pending. The primary use for a handler will be to run
callbacks. As a representation invariant, we require that only pending promises
may have handlers waiting in their list. Once the state becomes non-pending,
i.e., either resolved or rejected, the handlers will all be processed and
removed from the list.</p>
<p>This helper function that enqueues a handler on a promise’s handler list will be
helpful later:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="k">let</span> <span class="n">enqueue</span>
      <span class="o">(</span><span class="n">handler</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span>
      <span class="o">(</span><span class="n">promise</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span>
    <span class="o">=</span>
    <span class="n">promise</span><span class="o">.</span><span class="n">handlers</span> <span class="o">&lt;-</span> <span class="n">handler</span> <span class="o">::</span> <span class="n">promise</span><span class="o">.</span><span class="n">handlers</span>
</pre></div>
</div>
<p>We continue to pun resolvers and promises internally:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>
</pre></div>
</div>
<p>Because we changed the representation type from a <code class="docutils literal notranslate"><span class="pre">ref</span></code> to a record,
we have to update a few of the functions in trivial ways:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="c">(** [write_once p s] changes the state of [p] to be [s].  If [p] and [s]</span>
<span class="c">      are both pending, that has no effect.</span>
<span class="c">      Raises: [Invalid_arg] if the state of [p] is not pending. *)</span>
  <span class="k">let</span> <span class="n">write_once</span> <span class="n">p</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span>
    <span class="k">then</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span> <span class="o">&lt;-</span> <span class="n">s</span>
    <span class="k">else</span> <span class="n">invalid_arg</span> <span class="s2">&quot;cannot write twice&quot;</span>

  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span> <span class="k">in</span>
    <span class="n">p</span><span class="o">,</span> <span class="n">p</span>

  <span class="k">let</span> <span class="n">return</span> <span class="n">x</span> <span class="o">=</span>
    <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Resolved</span> <span class="n">x</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>

  <span class="k">let</span> <span class="n">state</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
<p>Now we get to the trickier parts of the implementation. To resolve or reject a
promise, the first thing we need to do is to call <code class="docutils literal notranslate"><span class="pre">write_once</span></code> on it, as we did
before. Now we also need to process the handlers. Before doing so, we mutate the
handlers list to be empty to ensure that the RI holds.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="c">(** requires: [st] may not be [Pending] *)</span>
  <span class="k">let</span> <span class="n">resolve_or_reject</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">assert</span> <span class="o">(</span><span class="n">st</span> <span class="o">&lt;&gt;</span> <span class="nc">Pending</span><span class="o">);</span>
    <span class="k">let</span> <span class="n">handlers</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">handlers</span> <span class="k">in</span>
    <span class="n">r</span><span class="o">.</span><span class="n">handlers</span> <span class="o">&lt;-</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">write_once</span> <span class="n">r</span> <span class="n">st</span><span class="o">;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">st</span><span class="o">)</span> <span class="n">handlers</span>

  <span class="k">let</span> <span class="n">reject</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">resolve_or_reject</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Rejected</span> <span class="n">x</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">resolve</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">resolve_or_reject</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Resolved</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
<p>Finally, the implementation of <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> is the trickiest part. First, if the
promise is already resolved, let’s go ahead and immediately run the callback on
it:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="k">let</span> <span class="o">(&gt;&gt;=)</span>
      <span class="o">(</span><span class="n">input_promise</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span><span class="o">)</span>
      <span class="o">(</span><span class="n">callback</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span>
    <span class="o">=</span>
    <span class="k">match</span> <span class="n">input_promise</span><span class="o">.</span><span class="n">state</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">callback</span> <span class="n">x</span>
</pre></div>
</div>
<p>Second, if the promise is already rejected, then we return a promise
that is rejected with the same exception:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Rejected</span> <span class="n">exc</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>
</pre></div>
</div>
<p>Third, if the promise is pending, we need to do more work. Here’s what we said
in our discussion of <code class="docutils literal notranslate"><span class="pre">bind</span></code> in the previous section:</p>
<blockquote>
<div><p>[T]he bind function returns a new promise. That promise will become
resolved when (or if) the callback completes running, sometime in the future.
Its contents will be whatever contents are contained within the promise that the
callback itself returns.</p>
</div></blockquote>
<p>That’s what we now need to implement. So, we create a new promise and resolver
called <code class="docutils literal notranslate"><span class="pre">output_promise</span></code> and <code class="docutils literal notranslate"><span class="pre">output_resolver</span></code>. That promise is what <code class="docutils literal notranslate"><span class="pre">bind</span></code>
returns. Before returning it, we use a helper function <code class="docutils literal notranslate"><span class="pre">handler_of_callback</span></code>
(described below) to transform the callback into a handler, and enqueue that
handler on the promise. That ensures the handler will be run when the promise
later becomes resolved or rejected:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">output_promise</span><span class="o">,</span> <span class="n">output_resolver</span> <span class="o">=</span> <span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
      <span class="n">enqueue</span> <span class="o">(</span><span class="n">handler_of_callback</span> <span class="n">callback</span> <span class="n">output_resolver</span><span class="o">)</span> <span class="n">input_promise</span><span class="o">;</span>
      <span class="n">output_promise</span>
</pre></div>
</div>
<p>All that’s left is to implement that helper function to create handlers from
callbacks. The first two cases, below, are simple. It would violate the RI to
call a handler on a pending state. And if the state is rejected, then the
handler should propagate that rejection to the resolver, which causes the
promise returned by bind to also be rejected.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="k">let</span> <span class="n">handler_of_callback</span>
      <span class="o">(</span><span class="n">callback</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span>
      <span class="o">(</span><span class="n">resolver</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span>
    <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;handler RI violated&quot;</span>
      <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
</pre></div>
</div>
<p>But if the state is resolved, then the callback provided by the user to bind
can—at last!—be run on the contents of the resolved promise. Running
the callback produces a new promise. It might already be rejected or resolved,
in which case that state again propagates.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>      <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">callback</span> <span class="n">x</span> <span class="k">in</span>
        <span class="k">match</span> <span class="n">promise</span><span class="o">.</span><span class="n">state</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">resolve</span> <span class="n">resolver</span> <span class="n">y</span>
        <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
</pre></div>
</div>
<p>But the promise might still be pending.  In that case, we need to enqueue
a new handler whose purpose is to do the propagation once the result is
available:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>        <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">handler</span> <span class="n">resolver</span><span class="o">)</span> <span class="n">promise</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">handler</span></code> is a new helper function that creates a very simple handler
to do that propagation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span>  <span class="k">let</span> <span class="n">handler</span> <span class="o">(</span><span class="n">resolver</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span>
    <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;handler RI violated&quot;</span>
      <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
      <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">resolve</span> <span class="n">resolver</span> <span class="n">x</span>
</pre></div>
</div>
<p>The Lwt implementation of <code class="docutils literal notranslate"><span class="pre">bind</span></code> follows essentially the same algorithm as we
just implemented. Note that there is no concurrency in <code class="docutils literal notranslate"><span class="pre">bind</span></code>: as we said above,
everything in Lwt is sequential; it’s the OS that provides the concurrency.</p>
</section>
<section id="the-full-implementation">
<h2><span class="section-number">8.6.10. </span>The Full Implementation<a class="headerlink" href="#the-full-implementation" title="Permalink to this headline">#</a></h2>
<p>Here’s all of that code in one executable block:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** A signature for Lwt-style promises, with better names *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nc">Pending</span>
    <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
    <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span>

  <span class="c">(** [make ()] is a new promise and resolver. The promise is pending. *)</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span>

  <span class="c">(** [return x] is a new promise that is already resolved with value</span>
<span class="c">      [x]. *)</span>
  <span class="k">val</span> <span class="n">return</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="c">(** [state p] is the state of the promise *)</span>
  <span class="k">val</span> <span class="n">state</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span>

  <span class="c">(** [resolve r x] resolves the promise [p] associated with [r] with</span>
<span class="c">      value [x], meaning that [state p] will become [Resolved x].</span>
<span class="c">      Requires: [p] is pending. *)</span>
  <span class="k">val</span> <span class="n">resolve</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(** [reject r x] rejects the promise [p] associated with [r] with</span>
<span class="c">      exception [x], meaning that [state p] will become [Rejected x].</span>
<span class="c">      Requires: [p] is pending. *)</span>
  <span class="k">val</span> <span class="n">reject</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">-&gt;</span> <span class="n">exn</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(** [p &gt;&gt;= c] registers callback [c] with promise [p].</span>
<span class="c">      When the promise is resolved, the callback will be run</span>
<span class="c">      on the promises&#39;s contents.  If the promise is never</span>
<span class="c">      resolved, the callback will never run. *)</span>
  <span class="k">val</span> <span class="o">(&gt;&gt;=)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Promise</span> <span class="o">:</span> <span class="nc">PROMISE</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span> <span class="o">|</span> <span class="nc">Resolved</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Rejected</span> <span class="k">of</span> <span class="n">exn</span>

  <span class="c">(** RI: the input may not be [Pending] *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(** RI: if [state &lt;&gt; Pending] then [handlers = []]. *)</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">mutable</span> <span class="n">state</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span><span class="o">;</span>
    <span class="k">mutable</span> <span class="n">handlers</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span> <span class="kt">list</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">enqueue</span>
      <span class="o">(</span><span class="n">handler</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span>
      <span class="o">(</span><span class="n">promise</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span><span class="o">)</span> <span class="o">:</span> <span class="kt">unit</span>
    <span class="o">=</span>
    <span class="n">promise</span><span class="o">.</span><span class="n">handlers</span> <span class="o">&lt;-</span> <span class="n">handler</span> <span class="o">::</span> <span class="n">promise</span><span class="o">.</span><span class="n">handlers</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span>

  <span class="c">(** [write_once p s] changes the state of [p] to be [s].  If [p] and [s]</span>
<span class="c">      are both pending, that has no effect.</span>
<span class="c">      Raises: [Invalid_arg] if the state of [p] is not pending. *)</span>
  <span class="k">let</span> <span class="n">write_once</span> <span class="n">p</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span>
    <span class="k">then</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span> <span class="o">&lt;-</span> <span class="n">s</span>
    <span class="k">else</span> <span class="n">invalid_arg</span> <span class="s2">&quot;cannot write twice&quot;</span>

  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Pending</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span> <span class="k">in</span>
    <span class="n">p</span><span class="o">,</span> <span class="n">p</span>

  <span class="k">let</span> <span class="n">return</span> <span class="n">x</span> <span class="o">=</span>
    <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Resolved</span> <span class="n">x</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>

  <span class="k">let</span> <span class="n">state</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">state</span>

  <span class="c">(** requires: [st] may not be [Pending] *)</span>
  <span class="k">let</span> <span class="n">resolve_or_reject</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">(</span><span class="n">st</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">state</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">assert</span> <span class="o">(</span><span class="n">st</span> <span class="o">&lt;&gt;</span> <span class="nc">Pending</span><span class="o">);</span>
    <span class="k">let</span> <span class="n">handlers</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">handlers</span> <span class="k">in</span>
    <span class="n">r</span><span class="o">.</span><span class="n">handlers</span> <span class="o">&lt;-</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">write_once</span> <span class="n">r</span> <span class="n">st</span><span class="o">;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">st</span><span class="o">)</span> <span class="n">handlers</span>

  <span class="k">let</span> <span class="n">reject</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">resolve_or_reject</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Rejected</span> <span class="n">x</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">resolve</span> <span class="n">r</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">resolve_or_reject</span> <span class="n">r</span> <span class="o">(</span><span class="nc">Resolved</span> <span class="n">x</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">handler</span> <span class="o">(</span><span class="n">resolver</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span>
    <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;handler RI violated&quot;</span>
      <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
      <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">resolve</span> <span class="n">resolver</span> <span class="n">x</span>

  <span class="k">let</span> <span class="n">handler_of_callback</span>
      <span class="o">(</span><span class="n">callback</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span>
      <span class="o">(</span><span class="n">resolver</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">resolver</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">handler</span>
    <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&quot;handler RI violated&quot;</span>
      <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
      <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">callback</span> <span class="n">x</span> <span class="k">in</span>
        <span class="k">match</span> <span class="n">promise</span><span class="o">.</span><span class="n">state</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">resolve</span> <span class="n">resolver</span> <span class="n">y</span>
        <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">reject</span> <span class="n">resolver</span> <span class="n">exc</span>
        <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="o">(</span><span class="n">handler</span> <span class="n">resolver</span><span class="o">)</span> <span class="n">promise</span>

  <span class="k">let</span> <span class="o">(&gt;&gt;=)</span>
      <span class="o">(</span><span class="n">input_promise</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">promise</span><span class="o">)</span>
      <span class="o">(</span><span class="n">callback</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span><span class="o">)</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">b</span> <span class="n">promise</span>
    <span class="o">=</span>
    <span class="k">match</span> <span class="n">input_promise</span><span class="o">.</span><span class="n">state</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Resolved</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">callback</span> <span class="n">x</span>
    <span class="o">|</span> <span class="nc">Rejected</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="n">state</span> <span class="o">=</span> <span class="nc">Rejected</span> <span class="n">exc</span><span class="o">;</span> <span class="n">handlers</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>
    <span class="o">|</span> <span class="nc">Pending</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">output_promise</span><span class="o">,</span> <span class="n">output_resolver</span> <span class="o">=</span> <span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
      <span class="n">enqueue</span> <span class="o">(</span><span class="n">handler_of_callback</span> <span class="n">callback</span> <span class="n">output_resolver</span><span class="o">)</span> <span class="n">input_promise</span><span class="o">;</span>
      <span class="n">output_promise</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>module type PROMISE =
  sig
    type &#39;a state = Pending | Resolved of &#39;a | Rejected of exn
    type &#39;a promise
    type &#39;a resolver
    val make : unit -&gt; &#39;a promise * &#39;a resolver
    val return : &#39;a -&gt; &#39;a promise
    val state : &#39;a promise -&gt; &#39;a state
    val resolve : &#39;a resolver -&gt; &#39;a -&gt; unit
    val reject : &#39;a resolver -&gt; exn -&gt; unit
    val ( &gt;&gt;= ) : &#39;a promise -&gt; (&#39;a -&gt; &#39;b promise) -&gt; &#39;b promise
  end
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>module Promise : PROMISE
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "ocaml-jupyter"
        },
        kernelOptions: {
            name: "ocaml-jupyter",
            path: "./chapters/ds"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'ocaml-jupyter'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="memoization.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.5. </span>Memoization</p>
      </div>
    </a>
    <a class="right-next"
       href="monads.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.7. </span>Monads</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#concurrency">8.6.1. Concurrency</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#threads">8.6.2. Threads</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">8.6.3. Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-our-own-promises">8.6.4. Making Our Own Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lwt-promises">8.6.5. Lwt Promises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#asynchronous-i-o">8.6.6. Asynchronous I/O</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#promises-and-asynchronous-i-o">8.6.7. Promises and Asynchronous I/O</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#callbacks">8.6.8. Callbacks</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implementing-callbacks">8.6.9. Implementing Callbacks</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-full-implementation">8.6.10. The Full Implementation</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            <div class="bd-footer-content__inner">
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Michael R. Clarkson et al.
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div></div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>