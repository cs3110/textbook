

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>8.2. Amortized Analysis &#8212; OCaml Programming: Correct + Efficient + Beautiful</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/ds/amortized';</script>
    <link rel="shortcut icon" href="../../_static/op.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8.3. Red-Black Trees" href="rb.html" />
    <link rel="prev" title="8.1. Hash Tables" href="hash_tables.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>
  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../cover.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/op_title.png" class="logo__image only-light" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>
    <script>document.write(`<img src="../../_static/op_title.png" class="logo__image only-dark" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../preface/about.html">About This Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface/install.html">Installing OCaml</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/intro.html">1. Better Programming Through OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/past.html">1.1. The Past of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/present.html">1.2. The Present of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/future.html">1.3. Look to Your Future</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/3110.html">1.4. A Brief History of CS 3110</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/summary.html">1.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../basics/intro.html">2. The Basics of OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../basics/toplevel.html">2.1. The OCaml Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/compiling.html">2.2. Compiling OCaml Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/expressions.html">2.3. Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/functions.html">2.4. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/documentation.html">2.5. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/printing.html">2.6. Printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/debugging.html">2.7. Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/summary.html">2.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/exercises.html">2.9. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">OCaml Programming</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../data/intro.html">3. Data and Types</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data/lists.html">3.1. Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/variants.html">3.2. Variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/ounit.html">3.3. Unit Testing with OUnit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/records_tuples.html">3.4. Records and Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/pattern_matching_advanced.html">3.5. Advanced Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/type_synonym.html">3.6. Type Synonyms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/options.html">3.7. Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/assoc_list.html">3.8. Association Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/algebraic_data_types.html">3.9. Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exceptions.html">3.10. Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/trees.html">3.11. Example: Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/nats.html">3.12. Example: Natural Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/summary.html">3.13. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exercises.html">3.14. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../hop/intro.html">4. Higher-Order Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../hop/higher_order.html">4.1. Higher-Order Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/map.html">4.2. Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/filter.html">4.3. Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/fold.html">4.4. Fold</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/beyond_lists.html">4.5. Beyond Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/pipelining.html">4.6. Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/currying.html">4.7. Currying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/summary.html">4.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/exercises.html">4.9. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../modules/intro.html">5. Modular Programming</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_systems.html">5.1. Module Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">5.2. Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/toplevel.html">5.3. Modules and the Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/encapsulation.html">5.4. Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/compilation_units.html">5.5. Compilation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functional_data_structures.html">5.6. Functional Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_type_constraints.html">5.7. Module Type Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/includes.html">5.8. Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functors.html">5.9. Functors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/summary.html">5.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/exercises.html">5.11. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Correctness and Efficiency</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../correctness/intro.html">6. Correctness</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../correctness/specifications.html">6.1. Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/function_docs.html">6.2. Function Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/module_docs.html">6.3. Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/test_debug.html">6.4. Testing and Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/black_glass_box.html">6.5. Black-box and Glass-box Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/randomized.html">6.6. Randomized Testing with QCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/proving_correctness.html">6.7. Proving Correctness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/structural_induction.html">6.8. Structural Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/eq_spec.html">6.9. Equational Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/summary.html">6.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/exercises.html">6.11. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mut/intro.html">7. Mutability</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mut/refs.html">7.1. Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/mutable_fields.html">7.2. Mutable Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/arrays.html">7.3. Arrays and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/summary.html">7.4. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/exercises.html">7.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">8. Data Structures</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hash_tables.html">8.1. Hash Tables</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.2. Amortized Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="rb.html">8.3. Red-Black Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="sequence.html">8.4. Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="memoization.html">8.5. Memoization</a></li>
<li class="toctree-l2"><a class="reference internal" href="parrays.html">8.6. Persistent Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="promises.html">8.7. Promises</a></li>
<li class="toctree-l2"><a class="reference internal" href="monads.html">8.8. Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">8.9. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="exercises.html">8.10. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Language Implementation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../interp/intro.html">9. Interpreters</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../interp/calculator.html">9.1. Example: Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/parsing.html">9.2. Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/substitution.html">9.3. Substitution Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/environment.html">9.4. Environment Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/typecheck.html">9.5. Type Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/inference.html">9.6. Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/summary.html">9.7. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/exercises.html">9.8. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lagniappe</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../adv/curry-howard.html">The Curry-Howard Correspondence</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix/bigoh.html">Big-Oh Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/vm.html">Virtual Machine</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/cs3110/textbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/edit/main/src/chapters/ds/amortized.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/ds/amortized.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chapters/ds/amortized.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Amortized Analysis</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-of-hash-tables">8.2.1. Amortized Analysis of Hash Tables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-of-batched-queues">8.2.2. Amortized Analysis of Batched Queues</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bankers-and-physicists">8.2.3. Bankers and Physicists</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-and-persistence">8.2.4. Amortized Analysis and Persistence</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="amortized-analysis">
<h1><span class="section-number">8.2. </span>Amortized Analysis<a class="headerlink" href="#amortized-analysis" title="Permalink to this heading">#</a></h1>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/1fPx0hcXlRg" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Our analysis of the efficiency of hash table operations concluded that <code class="docutils literal notranslate"><span class="pre">find</span></code>
runs in expected constant time, where the modifier “expected” is needed to
express the fact the performance is on average and depends on the hash function
satisfying certain properties.</p>
<p>We also concluded that <code class="docutils literal notranslate"><span class="pre">insert</span></code> would usually run in expected constant time, but
that in the worst case it would require linear time because of needing to rehash
the entire table. That kind of defeats the goal of a hash table, which is to
offer constant-time performance, or at least as close to it as we can get.</p>
<p>It turns out there is another way of looking at this analysis that allows us to
conclude that <code class="docutils literal notranslate"><span class="pre">insert</span></code> does have “amortized” expected constant time
performance—that is, for excusing the occasional worst-case linear
performance. Right away, we have to acknowledge this technique is just a change
in perspective. We’re not going to change the underlying algorithms. The
<code class="docutils literal notranslate"><span class="pre">insert</span></code> algorithm will still have worst-case linear performance. That’s a fact.</p>
<p>But the change in perspective we now undertake is to recognize that if it’s very
rare for <code class="docutils literal notranslate"><span class="pre">insert</span></code> to require linear time, then maybe we can “spread out” that
cost over all the other calls to <code class="docutils literal notranslate"><span class="pre">insert</span></code>. It’s a creative accounting trick!</p>
<p><strong>Sushi vs. Ramen.</strong> Let’s amuse ourselves with a real-world example for a
moment. Suppose that you have $20 to spend on lunches for the week. You like to
eat sushi, but you can’t afford to have sushi every day. So instead you eat as
follows:</p>
<ul class="simple">
<li><p>Monday: $1 ramen</p></li>
<li><p>Tuesday: $1 ramen</p></li>
<li><p>Wednesday: $1 ramen</p></li>
<li><p>Thursday: $1 ramen</p></li>
<li><p>Friday: $16 sushi</p></li>
</ul>
<p>Most of the time, your lunch was cheap. On a rare occasion, it was expensive. So
you could look at it in one of two ways:</p>
<ul class="simple">
<li><p>My worst-case lunch cost was $16.</p></li>
<li><p>My average lunch cost was $4.</p></li>
</ul>
<p>Both are true statements, but maybe the latter is more helpful in understanding
your spending habits.</p>
<p><strong>Back to Hash Tables.</strong> It’s the same with hash tables. Even though <code class="docutils literal notranslate"><span class="pre">insert</span></code> is
occasionally expensive, it’s so rarely expensive that the average cost of an
operation is actually constant time! But, we need to do more complicated math
(or more complicated than our lunch budgeting anyway) to actually demonstrate
that’s true.</p>
<section id="amortized-analysis-of-hash-tables">
<h2><span class="section-number">8.2.1. </span>Amortized Analysis of Hash Tables<a class="headerlink" href="#amortized-analysis-of-hash-tables" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/GwnYcPmn8PQ" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>“Amortization” is a financial term. One of its meanings is to pay off a debt
over time. In algorithmic analysis, we use it to refer to paying off the cost of
an expensive operation by inflating the cost of inexpensive operations. In
effect, we pre-pay the cost of a later expensive operation by adding some
additional cost to earlier cheap operations.</p>
<p>The <em>amortized complexity</em> or <em>amortized running time</em> of a sequence of
operations that each have cost <span class="math notranslate nohighlight">\(T_1, T_2, \ldots, T_n\)</span>, is just the average cost
of each operation:</p>
<div class="math notranslate nohighlight">
\[
\frac{T_1 + T_2 + \dotsb + T_n}{n}.
\]</div>
<p>Thus, even if one operation is especially expensive, we could average that out
over a bunch of inexpensive operations.</p>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/eKzgddLniSw" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Applying that idea to a hash table, let’s analyze what happens when an insert
operation causes an expensive resize. Assume the table resizes when the load
factor reaches 2. (That is more proactive than OCaml’s <code class="docutils literal notranslate"><span class="pre">Hashtbl</span></code>, which resizes
when the load factor <em>exceeds</em> 2. It doesn’t really matter which choice we make,
but resize-on-reaching will simplify our analysis a little.)</p>
<p>Suppose the table has 8 bindings and 8 buckets. Then 8 more inserts are made.
The first 7 are (expected) constant-time, but the 8th insert is linear time: it
increases the load factor to 2, causing a resize, thus causing rehashing of all
16 bindings into a new table. The total cost over that series of operations is
therefore: the cost of 8 inserts into the old table, plus the cost of allocating
a new 16-element table, plus the cost of 16 inserts into the new table.
That is, a total cost of 40.
So the average cost of each operation in the sequence is 40/8 = 5 inserts.</p>
<p>In other words, if we just pretended each insert cost five times its normal
price, the final operation in the sequence would have been “pre-paid” by the
extra price we paid for earlier inserts. And all of them would be constant-time,
since five times a constant is still a constant.</p>
<p>Generalizing from the example above, let’s suppose that the number of buckets
currently in a hash table is <span class="math notranslate nohighlight">\(2^n\)</span>, and that the load factor is currently 1.
Therefore, there are currently <span class="math notranslate nohighlight">\(2^n\)</span> bindings in the table. Next:</p>
<ul class="simple">
<li><p>A series of <span class="math notranslate nohighlight">\(2^n - 1\)</span> inserts occurs. There are now <span class="math notranslate nohighlight">\(2^n + 2^n - 1\)</span> bindings
in the table.</p></li>
<li><p>One more insert occurs. That brings the number of bindings up to <span class="math notranslate nohighlight">\(2^n + 2^n\)</span>,
which is <span class="math notranslate nohighlight">\(2^{n+1}\)</span>. But the number of buckets is <span class="math notranslate nohighlight">\(2^n\)</span>, so the load factor
just reached 2. A resize is necessary.</p></li>
<li><p>The resize occurs. It costs <span class="math notranslate nohighlight">\(2^{n+1}\)</span> to allocate memory for the new table.
That doubles the number of buckets. All <span class="math notranslate nohighlight">\(2^{n+1}\)</span> bindings
have to be reinserted into the new table, which is of size <span class="math notranslate nohighlight">\(2^{n+1}\)</span>. The load
factor is back down to 1.</p></li>
</ul>
<p>So in total we did <span class="math notranslate nohighlight">\(2^n + 2^{n+1}\)</span> inserts, which included <span class="math notranslate nohighlight">\(2^n\)</span> inserts of
bindings and <span class="math notranslate nohighlight">\(2^{n+1}\)</span> re-insertions after the resize. We also incurred the
cost of allocating a new table of size <span class="math notranslate nohighlight">\(2^{n+1}\)</span> in memory, and that cost is <span class="math notranslate nohighlight">\(2^{n+1}\)</span>.</p>
<p>Over a series of <span class="math notranslate nohighlight">\(2^n\)</span> insert operations, that’s
an average cost of <span class="math notranslate nohighlight">\(\frac{2^n + 2^{n+1} + 2^{n+1}}{2^n}\)</span>, which equals 5.
So if we just pretend each insert costs five times its normal price,
every operation in the sequence is amortized (and expected) constant time.</p>
<p><strong>Doubling vs. Constant-size Increasing.</strong> Notice that it is crucial that the
array size grows by doubling (or at least geometrically). A bad mistake would be
to instead grow the array by a fixed increment—for example, 100 buckets at
time. Then we’d be in real trouble as the number of bindings continued to grow:</p>
<ul class="simple">
<li><p>Start with 100 buckets and 100 bindings.  The load factor is 1.</p></li>
<li><p><strong>Round 1.</strong> Insert 100 bindings. There are now 200 bindings and 100 buckets.
The load factor is 2.</p></li>
<li><p>Increase the number of buckets by 100 and rehash. That’s 200 more insertions.
The load factor is back down to 1.</p></li>
<li><p>The average cost of each insert is so far just 3x the cost of an actual insert
(100+200 insertions / 100 bindings inserted). So far so good.</p></li>
<li><p><strong>Round 2.</strong> Insert 200 more bindings. There are now 400 bindings and 200
buckets. The load factor is 2.</p></li>
<li><p>Increase the number of buckets <strong>by 100</strong> and rehash. That’s 400 more
insertions. There are now 400 bindings and 300 buckets. The load factor is
400/300 = 4/3, not 1.</p></li>
<li><p>The average cost of each insert is now (100+200+200+400) / 300 = 3. That’s
still okay.</p></li>
<li><p><strong>Round 3.</strong> Insert 200 more bindings. There are now 600 bindings and 300
buckets. The load factor is 2.</p></li>
<li><p>Increase the number of buckets <strong>by 100</strong> and rehash. That’s 600 more
insertions. There are now 600 bindings and 400 buckets. The load factor is
3/2, not 1.</p></li>
<li><p>The average cost of each insert is now (100+200+200+400+200+600) / 500 = 3.4.
It’s going up.</p></li>
<li><p><strong>Round 4.</strong> Insert 200 more bindings. There are now 800 bindings and 400
buckets. The load factor is 2.</p></li>
<li><p>Increase the number of buckets <strong>by 100</strong> and rehash. That’s 800 more
insertions. There are now 800 bindings and 500 buckets. The load factor is
8/5, not 1.</p></li>
<li><p>The average cost of each insert is now (100+200+200+400+200+600+200+800) / 700
= 3.9. It’s continuing to go up, not staying constant.</p></li>
</ul>
<p>After <span class="math notranslate nohighlight">\(k\)</span> rounds we have <span class="math notranslate nohighlight">\(200k\)</span> bindings and <span class="math notranslate nohighlight">\(100(k+1)\)</span> buckets. We have called
<code class="docutils literal notranslate"><span class="pre">insert</span></code> to insert <span class="math notranslate nohighlight">\(100+200(k-1)\)</span> bindings, but all the rehashing has caused us to
do <span class="math notranslate nohighlight">\(100+200(k-1)+\sum_{i=1}^{k} 200i\)</span> actual insertions. That last term is the
real problem. It’s quadratic:</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^{k} 200i \quad = \quad 200 \sum_{i=1}^k i = \quad 200 \frac{k(k+1)}{2} \quad = \quad 100 (k^2 + k) .
\]</div>
<p>So over a series of <span class="math notranslate nohighlight">\(n\)</span> calls to <code class="docutils literal notranslate"><span class="pre">insert</span></code>, we do <span class="math notranslate nohighlight">\(O(n^2)\)</span> actual inserts. That
makes the amortized cost of <code class="docutils literal notranslate"><span class="pre">insert</span></code> be <span class="math notranslate nohighlight">\(O(n)\)</span>, which is linear! Not constant.</p>
<p>That’s why it’s so important to double the size of the array at each rehash.
It’s what gives us the amortized constant-time performance.</p>
</section>
<section id="amortized-analysis-of-batched-queues">
<h2><span class="section-number">8.2.2. </span>Amortized Analysis of Batched Queues<a class="headerlink" href="#amortized-analysis-of-batched-queues" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/7OV9iKT0Huw" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The implementation of <a class="reference internal" href="../modules/functional_data_structures.html"><span class="doc std std-doc">batched queues</span></a> with two lists was in a way more
efficient than the implementation with just one list, because it managed to
achieve a constant time <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> operation. But, that came at the tradeoff of
making the <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> operation sometimes take more than constant time: whenever
the outbox became empty, the inbox had to be reversed, which required an
additional linear-time operation.</p>
<p>As we observed then, the reversal is relatively rare. It happens only when the
outbox gets exhausted. Amortized analysis gives us a way to account for that. We
can actually show that the <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> operation is amortized constant time.</p>
<p>To keep the analysis simple at first, let’s assume the queue starts off with
exactly one element <code class="docutils literal notranslate"><span class="pre">1</span></code> already enqueued, and that we do three <code class="docutils literal notranslate"><span class="pre">enqueue</span></code>
operations of <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, then <code class="docutils literal notranslate"><span class="pre">4</span></code>, followed by a single <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>. The single
initial element would end up in the outbox. All three <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> operations would
cons an element onto the inbox. So just before the <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>, the queue looks
like:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="n">o</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="n">i</span> <span class="o">=</span> <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">2</span><span class="o">]}</span>
</pre></div>
</div>
<p>and after the <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="n">o</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">];</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">[]</span><span class="o">}</span>
</pre></div>
</div>
<p>It required</p>
<ul class="simple">
<li><p>3 cons operations to do the 3 enqueues, and</p></li>
<li><p>another 3 cons operations to finish the dequeue by reversing the list.</p></li>
</ul>
<p>That’s a total of 6 cons operations to do the 4 <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> and <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>
operations. The average cost is therefore 1.5 cons operations per queue
operation. There were other pattern matching operations and record
constructions, but those all took only constant time, so we’ll ignore them.</p>
<p>What about a more complicated situation, where there are <code class="docutils literal notranslate"><span class="pre">enqueues</span></code> and
<code class="docutils literal notranslate"><span class="pre">dequeues</span></code> interspersed with one another? Trying to take averages over the
series is going to be tricky to analyze. But, inspired by our analysis of hash
tables, suppose we pretend that the cost of each <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> is twice its actual
cost, as measured in cons operations? Then at the time an element is enqueued,
we could “prepay” the later cost that will be incurred when that element is
cons’d onto the reversed list.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">enqueue</span></code> operation is still constant time, because even though we’re now
pretending its cost is 2 instead of 1, it’s still the case that 2 is a constant.
And the <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> operation is amortized constant time:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> doesn’t need to reverse the inbox, it really does just constant
work, and</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> does need to reverse an inbox with <span class="math notranslate nohighlight">\(n\)</span> elements, it already
has <span class="math notranslate nohighlight">\(n\)</span> units of work “saved up” from each of the enqueues of those <span class="math notranslate nohighlight">\(n\)</span>
elements.</p></li>
</ul>
<p>So if we just pretend each enqueue costs twice its normal price, every operation
in a sequence is amortized constant time. Is this just a bookkeeping trick?
Absolutely. But it also reveals the deeper truth that on average we get
constant-time performance, even though some operations might rarely have
worst-case linear-time performance.</p>
</section>
<section id="bankers-and-physicists">
<h2><span class="section-number">8.2.3. </span>Bankers and Physicists<a class="headerlink" href="#bankers-and-physicists" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/-846PptyO7Q" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Conceptually, amortized analysis can be understood in three ways:</p>
<ol class="arabic simple">
<li><p>Taking the average cost over a series of operations. This is what we’ve done
so far.</p></li>
<li><p>Keeping a “bank account” at each individual element of a data structure. Some
operations deposit credits, and others withdraw them. The goal is for account
totals to never be negative. The amortized cost of any operation is the
actual cost, plus any credits deposited, minus any credits spent. So if an
operation actually costs <span class="math notranslate nohighlight">\(n\)</span> but spends <span class="math notranslate nohighlight">\(n-1\)</span> credits, then its amortized
cost is just <span class="math notranslate nohighlight">\(1\)</span>. This is called the <em>banker’s method</em> of amortized analysis.</p></li>
<li><p>Regarding the entire data structure as having an amount of “potential energy”
stored up. Some operations increase the energy, some decrease it. The energy
should never be negative. The amortized cost of any operation is its actual
cost, plus the change in potential energy. So if an operation actually costs
<span class="math notranslate nohighlight">\(n\)</span>, and before the operation the potential energy is <span class="math notranslate nohighlight">\(n\)</span>, and after the
operation the potential energy is <span class="math notranslate nohighlight">\(0\)</span>, then the amortized cost is <span class="math notranslate nohighlight">\(n + (0 -
n)\)</span>, which is just <span class="math notranslate nohighlight">\(0\)</span>. This is called the <em>physicist’s method</em> of amortized
analysis.</p></li>
</ol>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/ICT_TfQUa8w" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The banker’s and physicist’s methods can be easier to use in many situations
than a complicated analysis of a series of operations. Let’s revisit our
examples so far to illustrate their use:</p>
<ul class="simple">
<li><p><strong>Banker’s method, hash tables:</strong> The table starts off empty. When a binding
is added to the table, save up 1 credit in its account. When a rehash becomes
necessary, every binding is guaranteed to have 1 credit. Use that credit to
pay for the rehash. Now all bindings have 0 credits. From now on, when a
binding is added to the table, save up 1 credit in its account and 1 credit in
the account of any one of the bindings that has 0 credits. At the time the
next rehash becomes necessary, the number of bindings has doubled. But since
we’ve saved 2 credits at each insertion, every binding now has 1 credit in its
account again. So we can pay for the rehash. The accounts never go negative,
because they always have either 0 or 1 credit.</p></li>
<li><p><strong>Banker’s method, batched queues:</strong> When an element is added to the queue,
save up 1 credit in its account. When the inbox must be reversed, use the
credit in each element to pay for the cons onto the outbox. Since elements
enter at the inbox and transition at most once to the outbox, every element
will have 0 or 1 credits. So the accounts never go negative.</p></li>
<li><p><strong>Physicist’s method, hash tables:</strong> At first, define the potential energy of
the table to be the number of bindings inserted. That energy will therefore
never be negative. Each insertion increases the energy by 1 unit. When the
first rehash is needed after inserting <span class="math notranslate nohighlight">\(n\)</span> bindings, the potential energy is
<span class="math notranslate nohighlight">\(n\)</span>. The potential goes back down to <span class="math notranslate nohighlight">\(0\)</span> at the rehash. So the actual cost is
<span class="math notranslate nohighlight">\(n\)</span>, but the change in potential is <span class="math notranslate nohighlight">\(n\)</span>, which makes the amortized cost <span class="math notranslate nohighlight">\(0\)</span>,
or constant. From now on, define the potential energy to be twice the number
of bindings inserted since the last rehash. Again, the energy will never be
negative. Each insertion increases the energy by 2 units. When the next rehash
is needed after inserting <span class="math notranslate nohighlight">\(n\)</span> bindings, there will be <span class="math notranslate nohighlight">\(2n\)</span> bindings that need
to be rehashed. Again, the amortized cost will be constant, because the actual
cost of <span class="math notranslate nohighlight">\(2n\)</span> re-insertions is offset by the <span class="math notranslate nohighlight">\(2n\)</span> change in potential.</p></li>
<li><p><strong>Physicist’s method, batched queues:</strong> Define the potential energy of the
queue to be the length of the inbox. It therefore will never be negative. When
a <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> has to reverse an inbox of length <span class="math notranslate nohighlight">\(n\)</span>, there is an actual cost of
<span class="math notranslate nohighlight">\(n\)</span> but a change in potential of <span class="math notranslate nohighlight">\(n\)</span> too, which offsets the cost and makes it
constant.</p></li>
</ul>
<p>The two methods are equivalent in their analytical power:</p>
<ul class="simple">
<li><p>To convert a banker’s analysis into a physicist’s, just make the potential be
the sum of all the credits in the individual accounts.</p></li>
<li><p>To convert a physicist’s analysis into a banker’s, just designate one
distinguished element of the data structure to be the only one that will ever
hold any credits, and have each operation deposit or withdraw the change in
potential into that element’s account.</p></li>
</ul>
<p>So, the choice of which to use really just depends on which is easier for the
data structure being analyzed, or which is easier for you to wrap your head
around. You might find one or the other of the methods easier to understand for
the data structures above, and your friend might have a different opinion.</p>
</section>
<section id="amortized-analysis-and-persistence">
<h2><span class="section-number">8.2.4. </span>Amortized Analysis and Persistence<a class="headerlink" href="#amortized-analysis-and-persistence" title="Permalink to this heading">#</a></h2>
<p>Amortized analysis breaks down as a technique when data structures are used
persistently. For example, suppose we have a batched queue <code class="docutils literal notranslate"><span class="pre">q</span></code> into which we’ve
inserted <span class="math notranslate nohighlight">\(n+1\)</span> elements. One element will be in the outbox, and the other <span class="math notranslate nohighlight">\(n\)</span>
will be in the inbox. Now we do the following:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">dequeue</span> <span class="n">q</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">dequeue</span> <span class="n">q</span>
<span class="o">...</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">qn</span> <span class="o">=</span> <span class="n">dequeue</span> <span class="n">q</span>
</pre></div>
</div>
<p>Each one of those <span class="math notranslate nohighlight">\(n\)</span> <code class="docutils literal notranslate"><span class="pre">dequeue</span></code> operations requires an actual cost of <span class="math notranslate nohighlight">\(O(n)\)</span> to
reverse the inbox. So the entire series has an actual cost of <span class="math notranslate nohighlight">\(O(n^2)\)</span>. But
the amortized analysis techniques only apply to the first <code class="docutils literal notranslate"><span class="pre">dequeue</span></code>. After that,
all the accounts are empty (banker’s method), or the potential is zero
(physicist’s), which means the remaining operations can’t use them to pay for
the expensive list reversal. The total cost of the series is therefore <span class="math notranslate nohighlight">\(O(n^2 -
n)\)</span>, which is <span class="math notranslate nohighlight">\(O(n^2)\)</span>.</p>
<p>The problem with persistence is that it violates the assumption built-in to
amortized analysis that credits (or energy units) are spent only once. Every
persistent copy of the data structure instead tries to spend them itself, not
being aware of all the other copies.</p>
<p>There are more advanced techniques for amortized analysis that can account for
persistence. Those techniques are based on the idea of accumulating <em>debt</em> that
is later paid off, rather than accumulating savings that are later spent. The
reason that debt ends up working as an analysis technique can be summed up as:
although our banks would never (financially speaking) allow us to spend money
twice, they would be fine with us paying off our debt multiple times. Consult
Okasaki’s <em>Purely Functional Data Structures</em> to learn more.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "cs3110/textbook",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapters/ds"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="hash_tables.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.1. </span>Hash Tables</p>
      </div>
    </a>
    <a class="right-next"
       href="rb.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.3. </span>Red-Black Trees</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-of-hash-tables">8.2.1. Amortized Analysis of Hash Tables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-of-batched-queues">8.2.2. Amortized Analysis of Batched Queues</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bankers-and-physicists">8.2.3. Bankers and Physicists</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#amortized-analysis-and-persistence">8.2.4. Amortized Analysis and Persistence</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Michael R. Clarkson et al.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>