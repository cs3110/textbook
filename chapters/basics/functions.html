

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>2.4. Functions &#8212; OCaml Programming: Correct + Efficient + Beautiful</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/basics/functions';</script>
    <link rel="shortcut icon" href="../../_static/op.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.5. Documentation" href="documentation.html" />
    <link rel="prev" title="2.3. Expressions" href="expressions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>
  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../cover.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/op_title.png" class="logo__image only-light" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>
    <script>document.write(`<img src="../../_static/op_title.png" class="logo__image only-dark" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../preface/about.html">About This Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface/install.html">Installing OCaml</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/intro.html">1. Better Programming Through OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/past.html">1.1. The Past of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/present.html">1.2. The Present of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/future.html">1.3. Look to Your Future</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/3110.html">1.4. A Brief History of CS 3110</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/summary.html">1.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">2. The Basics of OCaml</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="toplevel.html">2.1. The OCaml Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiling.html">2.2. Compiling OCaml Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressions.html">2.3. Expressions</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">2.4. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html">2.5. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="printing.html">2.6. Printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">2.7. Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">2.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="exercises.html">2.9. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">OCaml Programming</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../data/intro.html">3. Data and Types</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data/lists.html">3.1. Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/variants.html">3.2. Variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/ounit.html">3.3. Unit Testing with OUnit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/records_tuples.html">3.4. Records and Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/pattern_matching_advanced.html">3.5. Advanced Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/type_synonym.html">3.6. Type Synonyms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/options.html">3.7. Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/assoc_list.html">3.8. Association Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/algebraic_data_types.html">3.9. Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exceptions.html">3.10. Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/trees.html">3.11. Example: Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/nats.html">3.12. Example: Natural Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/summary.html">3.13. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exercises.html">3.14. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../hop/intro.html">4. Higher-Order Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../hop/higher_order.html">4.1. Higher-Order Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/map.html">4.2. Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/filter.html">4.3. Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/fold.html">4.4. Fold</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/beyond_lists.html">4.5. Beyond Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/pipelining.html">4.6. Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/currying.html">4.7. Currying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/summary.html">4.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/exercises.html">4.9. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../modules/intro.html">5. Modular Programming</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_systems.html">5.1. Module Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">5.2. Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/toplevel.html">5.3. Modules and the Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/encapsulation.html">5.4. Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/compilation_units.html">5.5. Compilation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functional_data_structures.html">5.6. Functional Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_type_constraints.html">5.7. Module Type Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/includes.html">5.8. Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functors.html">5.9. Functors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/summary.html">5.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/exercises.html">5.11. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Correctness and Efficiency</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../correctness/intro.html">6. Correctness</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../correctness/specifications.html">6.1. Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/function_docs.html">6.2. Function Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/module_docs.html">6.3. Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/test_debug.html">6.4. Testing and Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/black_glass_box.html">6.5. Black-box and Glass-box Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/randomized.html">6.6. Randomized Testing with QCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/proving_correctness.html">6.7. Proving Correctness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/structural_induction.html">6.8. Structural Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/eq_spec.html">6.9. Equational Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/summary.html">6.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../correctness/exercises.html">6.11. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mut/intro.html">7. Mutability</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mut/refs.html">7.1. Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/mutable_fields.html">7.2. Mutable Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/arrays.html">7.3. Arrays and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/summary.html">7.4. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/exercises.html">7.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ds/intro.html">8. Data Structures</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ds/hash_tables.html">8.1. Hash Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/amortized.html">8.2. Amortized Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/rb.html">8.3. Red-Black Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/sequence.html">8.4. Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/memoization.html">8.5. Memoization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/parrays.html">8.6. Persistent Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/promises.html">8.7. Promises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/monads.html">8.8. Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/summary.html">8.9. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/exercises.html">8.10. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Language Implementation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../interp/intro.html">9. Interpreters</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../interp/calculator.html">9.1. Example: Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/parsing.html">9.2. Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/substitution.html">9.3. Substitution Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/environment.html">9.4. Environment Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/typecheck.html">9.5. Type Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/inference.html">9.6. Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/summary.html">9.7. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/exercises.html">9.8. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lagniappe</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../adv/curry-howard.html">The Curry-Howard Correspondence</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix/bigoh.html">Big-Oh Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/vm.html">Virtual Machine</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/cs3110/textbook/main?urlpath=tree/src/chapters/basics/functions.md" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/cs3110/textbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/edit/main/src/chapters/basics/functions.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/basics/functions.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chapters/basics/functions.ipynb" target="_blank"
   class="btn btn-sm btn-download-notebook-button dropdown-item"
   title="Download notebook file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li><a href="../../_sources/chapters/basics/functions.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Functions</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-definitions">2.4.1. Function Definitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#anonymous-functions">2.4.2. Anonymous Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-application">2.4.3. Function Application</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pipeline">2.4.4. Pipeline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#polymorphic-functions">2.4.5. Polymorphic Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#labeled-and-optional-arguments">2.4.6. Labeled and Optional Arguments</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-application">2.4.7. Partial Application</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-associativity">2.4.8. Function Associativity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operators-as-functions">2.4.9. Operators as Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tail-recursion">2.4.10. Tail Recursion</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="functions">
<h1><span class="section-number">2.4. </span>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">#</a></h1>
<p>Since OCaml is a functional language, there’s a lot to cover about functions.
Let’s get started.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Methods and functions are not the same idea. A method is a component of an
object, and it implicitly has a receiver that is usually accessed with a keyword
like <code class="docutils literal notranslate"><span class="pre">this</span></code> or <code class="docutils literal notranslate"><span class="pre">self</span></code>. OCaml functions are not methods: they are not components
of objects, and they do not have a receiver.</p>
<p>Some might say that all methods are functions, but not all functions are
methods. Some might even quibble with that, making a distinction between
functions and procedures. The latter would be functions that do not return any
meaningful value, such as a <code class="docutils literal notranslate"><span class="pre">void</span></code> return type in Java or <code class="docutils literal notranslate"><span class="pre">None</span></code> return value in
Python.</p>
<p>So if you’re coming from an object-oriented background, be careful about the
terminology. <strong>Everything here is strictly a function, not a method.</strong></p>
</div>
<section id="function-definitions">
<h2><span class="section-number">2.4.1. </span>Function Definitions<a class="headerlink" href="#function-definitions" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/vCxIlagS7kA" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The following code</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
<p>has an expression in it (<code class="docutils literal notranslate"><span class="pre">42</span></code>) but is not itself an expression. Rather, it is a
<em>definition</em>. Definitions bind values to names, in this case the value <code class="docutils literal notranslate"><span class="pre">42</span></code>
being bound to the name <code class="docutils literal notranslate"><span class="pre">x</span></code>. The OCaml manual describes
<a class="reference external" href="https://ocaml.org/manual/modules.html">definitions</a> (see the third major grouping titled “<em>definition</em>”
on that page), but that manual page is again primarily for reference not for
study. Definitions are not expressions, nor are expressions
definitions—they are distinct syntactic classes.</p>
<p>For now, let’s focus on one particular kind of definition, a <em>function
definition</em>. Non-recursive functions are defined like this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/_x82qitu2R8" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Recursive functions are defined like this:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>The difference is just the <code class="docutils literal notranslate"><span class="pre">rec</span></code> keyword. It’s probably a bit surprising that
you explicitly have to add a keyword to make a function recursive, because most
languages assume by default that they are. OCaml doesn’t make that assumption,
though. (Nor does the Scheme family of languages.)</p>
<p>One of the best known recursive functions is the factorial function. In OCaml,
it can be written as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [fact n] is [n!].</span>
<span class="c">    Requires: [n &gt;= 0]. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">fact</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>We provided a specification comment above the function to document the
precondition (<code class="docutils literal notranslate"><span class="pre">Requires</span></code>) and postcondition (<code class="docutils literal notranslate"><span class="pre">is</span></code>) of the function.</p>
<p>Note that, as in many languages, OCaml integers are not the “mathematical”
integers but are limited to a fixed number of bits. The <a class="reference external" href="https://ocaml.org/manual/values.html#sss:values:integer">manual</a> specifies
that (signed) integers are at least 31 bits, but they could be wider. As
architectures have grown, so has that size. In current implementations, OCaml
integers are 63 bits. So if you test on large enough inputs, you might begin to
see strange results. The problem is machine arithmetic, not OCaml. (For
interested readers: why 31 or 63 instead of 32 or 64? The OCaml garbage
collector needs to distinguish between integers and pointers. The runtime
representation of these therefore steals one bit to flag whether a word is an
integer or a pointer.)</p>
<p>Here’s another recursive function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [pow x y] is [x] to the power of [y].</span>
<span class="c">     Requires: [y &gt;= 0]. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">pow</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val pow : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Note how we didn’t have to write any types in either of our functions: the OCaml
compiler infers them for us automatically. The compiler solves this <em>type
inference</em> problem algorithmically, but we could do it ourselves, too. It’s like
a mystery that can be solved by our mental power of deduction:</p>
<ul class="simple">
<li><p>Since the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression can return <code class="docutils literal notranslate"><span class="pre">1</span></code> in the <code class="docutils literal notranslate"><span class="pre">then</span></code> branch, we know by the
typing rule for <code class="docutils literal notranslate"><span class="pre">if</span></code> that the entire <code class="docutils literal notranslate"><span class="pre">if</span></code> expression has type <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p></li>
<li><p>Since the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression has type <code class="docutils literal notranslate"><span class="pre">int</span></code>, the function’s return type must be
<code class="docutils literal notranslate"><span class="pre">int</span></code>.</p></li>
<li><p>Since <code class="docutils literal notranslate"><span class="pre">y</span></code> is compared to <code class="docutils literal notranslate"><span class="pre">0</span></code> with the equality operator, <code class="docutils literal notranslate"><span class="pre">y</span></code> must be an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p></li>
<li><p>Since <code class="docutils literal notranslate"><span class="pre">x</span></code> is multiplied with another expression using the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator, <code class="docutils literal notranslate"><span class="pre">x</span></code>
must be an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p></li>
</ul>
<p>If we wanted to write down the types for some reason, we could do that:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">pow</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>The parentheses are mandatory when we write the <em>type annotations</em> for <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>. We will generally leave out these annotations, because it’s simpler to let
the compiler infer them. There are other times when you’ll want to explicitly
write down types. One particularly useful time is when you get a type error from
the compiler that you don’t understand. Explicitly annotating the types can help
with debugging such an error message.</p>
<p><strong>Syntax.</strong>
The syntax for function definitions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x1</span> <span class="n">x2</span> <span class="o">...</span> <span class="n">xn</span> <span class="o">=</span> <span class="n">e</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">f</span></code> is a metavariable indicating an identifier being used as a function
name. These identifiers must begin with a lowercase letter. The remaining
<a class="reference external" href="https://ocaml.org/manual/lex.html#lowercase-ident">rules for lowercase identifiers</a> can be found in the manual. The
names <code class="docutils literal notranslate"><span class="pre">x1</span></code> through <code class="docutils literal notranslate"><span class="pre">xn</span></code> are metavariables indicating argument identifiers. These
follow the same rules as function identifiers. The keyword <code class="docutils literal notranslate"><span class="pre">rec</span></code> is required if
<code class="docutils literal notranslate"><span class="pre">f</span></code> is to be a recursive function; otherwise it may be omitted.</p>
<p>Note that syntax for function definitions is actually simplified compared to
what OCaml really allows. We will learn more about some augmented syntax for
function definition in the next couple of weeks. But for now, this simplified
version will help us focus.</p>
<p>Mutually recursive functions can be defined with the <code class="docutils literal notranslate"><span class="pre">and</span></code> keyword:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">f</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xn</span> <span class="o">=</span> <span class="n">e1</span>
<span class="k">and</span> <span class="n">g</span> <span class="n">y1</span> <span class="o">...</span> <span class="n">yn</span> <span class="o">=</span> <span class="n">e2</span>
</pre></div>
</div>
<p>For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [even n] is whether [n] is even.</span>
<span class="c">    Requires: [n &gt;= 0]. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">even</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="c">(** [odd n] is whether [n] is odd.</span>
<span class="c">    Requires: [n &gt;= 0]. *)</span>
<span class="k">and</span> <span class="n">odd</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">even</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val even : int -&gt; bool = &lt;fun&gt;
val odd : int -&gt; bool = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/W0rO84YXIXo" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The syntax for function types is:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span>
<span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">u</span>
<span class="n">t1</span> <span class="o">-&gt;</span> <span class="o">...</span> <span class="o">-&gt;</span> <span class="n">tn</span> <span class="o">-&gt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span></code> are metavariables indicating types. Type <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code> is the type of
a function that takes an input of type <code class="docutils literal notranslate"><span class="pre">t</span></code> and returns an output of type <code class="docutils literal notranslate"><span class="pre">u</span></code>. We
can think of <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code> as the type of a function that takes two inputs,
the first of type <code class="docutils literal notranslate"><span class="pre">t1</span></code> and the second of type <code class="docutils literal notranslate"><span class="pre">t2</span></code>, and returns an output of
type <code class="docutils literal notranslate"><span class="pre">u</span></code>. Likewise for a function that takes <code class="docutils literal notranslate"><span class="pre">n</span></code> arguments.</p>
<p><strong>Dynamic semantics.</strong> There is no dynamic semantics of function definitions.
There is nothing to be evaluated. OCaml just records that the name <code class="docutils literal notranslate"><span class="pre">f</span></code> is bound
to a function with the given arguments <code class="docutils literal notranslate"><span class="pre">x1..xn</span></code> and the given body <code class="docutils literal notranslate"><span class="pre">e</span></code>. Only
later, when the function is applied, will there be some evaluation to do.</p>
<p><strong>Static semantics.</strong> The static semantics of function definitions:</p>
<ul class="simple">
<li><p>For non-recursive functions: if by assuming that <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">:</span> <span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span> <span class="pre">:</span> <span class="pre">t2</span></code> and …
and <code class="docutils literal notranslate"><span class="pre">xn</span> <span class="pre">:</span> <span class="pre">tn</span></code>, we can conclude that <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">u</span></code>, then
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">tn</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code>.</p></li>
<li><p>For recursive functions: if by assuming that <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">:</span> <span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span> <span class="pre">:</span> <span class="pre">t2</span></code> and …
and <code class="docutils literal notranslate"><span class="pre">xn</span> <span class="pre">:</span> <span class="pre">tn</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">tn</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code>, we can conclude that
<code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">u</span></code>, then <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">tn</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code>.</p></li>
</ul>
<p>Note how the type checking rule for recursive functions assumes that the
function identifier <code class="docutils literal notranslate"><span class="pre">f</span></code> has a particular type, then checks to see whether the
body of the function is well-typed under that assumption. This is because <code class="docutils literal notranslate"><span class="pre">f</span></code> is
in scope inside the function body itself (just like the arguments are in scope).</p>
</section>
<section id="anonymous-functions">
<h2><span class="section-number">2.4.2. </span>Anonymous Functions<a class="headerlink" href="#anonymous-functions" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/JwoIIrj0bcM" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>We already know that we can have values that are not bound to names.
The integer <code class="docutils literal notranslate"><span class="pre">42</span></code>, for example, can be entered at the toplevel without
giving it a name:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 42
</pre></div>
</div>
</div>
</div>
<p>Or we can bind it to a name:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val x : int = 42
</pre></div>
</div>
</div>
</div>
<p>Similarly, OCaml functions do not have to have names; they may be <em>anonymous</em>.
For example, here is an anonymous function that increments its input:
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>. Here, <code class="docutils literal notranslate"><span class="pre">fun</span></code> is a keyword indicating an anonymous function, <code class="docutils literal notranslate"><span class="pre">x</span></code>
is the argument, and <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> separates the argument from the body.</p>
<p>We now have two ways we could write an increment function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">inc</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val inc : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val inc : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>They are syntactically different but semantically equivalent. That is, even
though they involve different keywords and put some identifiers in different
places, they mean the same thing.</p>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/zHHCD7MOjmw" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Anonymous functions are also called <em>lambda expressions</em>, a term that comes from
the <em>lambda calculus</em>, which is a mathematical model of computation in the same
sense that Turing machines are a model of computation. In the lambda calculus,
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> would be written <span class="math notranslate nohighlight">\(\lambda x . e\)</span>. The <span class="math notranslate nohighlight">\(\lambda\)</span> denotes an
anonymous function.</p>
<p>It might seem a little mysterious right now why we would want functions that
have no names. Don’t worry; we’ll see good uses for them later in the course,
especially when we study so-called “higher-order programming”. In particular, we
will often create anonymous functions and pass them as input to other functions.</p>
<p><strong>Syntax.</strong></p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xn</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
<p><strong>Static semantics.</strong></p>
<ul class="simple">
<li><p>If by assuming that
<code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">:</span> <span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span> <span class="pre">:</span> <span class="pre">t2</span></code> and … and <code class="docutils literal notranslate"><span class="pre">xn</span> <span class="pre">:</span> <span class="pre">tn</span></code>, we can conclude that <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">u</span></code>,
then <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">tn</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code>.</p></li>
</ul>
<p><strong>Dynamic semantics.</strong> An anonymous function is already a value. There is no
computation to be performed.</p>
</section>
<section id="function-application">
<h2><span class="section-number">2.4.3. </span>Function Application<a class="headerlink" href="#function-application" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/fgCTDhXAYnQ" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Here we cover a somewhat simplified syntax of function application compared to
what OCaml actually allows.</p>
<p><strong>Syntax.</strong></p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">e0</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">...</span> <span class="n">en</span>
</pre></div>
</div>
<p>The first expression <code class="docutils literal notranslate"><span class="pre">e0</span></code> is the function, and it is applied to arguments <code class="docutils literal notranslate"><span class="pre">e1</span></code>
through <code class="docutils literal notranslate"><span class="pre">en</span></code>. Note that parentheses are not required around the arguments to
indicate function application, as they are in languages in the C family,
including Java.</p>
<p><strong>Static semantics.</strong></p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">tn</span> <span class="pre">-&gt;</span> <span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">:</span> <span class="pre">t1</span></code> and … and <code class="docutils literal notranslate"><span class="pre">en</span> <span class="pre">:</span> <span class="pre">tn</span></code>
then <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span> <span class="pre">...</span> <span class="pre">en</span> <span class="pre">:</span> <span class="pre">u</span></code>.</p></li>
</ul>
<p><strong>Dynamic semantics.</strong></p>
<p>To evaluate <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span> <span class="pre">...</span> <span class="pre">en</span></code>:</p>
<ol class="arabic">
<li><p>Evaluate <code class="docutils literal notranslate"><span class="pre">e0</span></code> to a function. Also evaluate the argument expressions <code class="docutils literal notranslate"><span class="pre">e1</span></code>
through <code class="docutils literal notranslate"><span class="pre">en</span></code> to values <code class="docutils literal notranslate"><span class="pre">v1</span></code> through <code class="docutils literal notranslate"><span class="pre">vn</span></code>.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">e0</span></code>, the result might be an anonymous function <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> or a name <code class="docutils literal notranslate"><span class="pre">f</span></code>. In the latter case, we need to find the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code>,
which we can assume to be of the form <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span> <span class="pre">f</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">e</span></code>.  Either way, we now know the argument names <code class="docutils literal notranslate"><span class="pre">x1</span></code> through <code class="docutils literal notranslate"><span class="pre">xn</span></code> and the
body <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</li>
<li><p>Substitute each value <code class="docutils literal notranslate"><span class="pre">vi</span></code> for the corresponding argument name <code class="docutils literal notranslate"><span class="pre">xi</span></code> in the
body <code class="docutils literal notranslate"><span class="pre">e</span></code> of the function. That substitution results in a new expression <code class="docutils literal notranslate"><span class="pre">e'</span></code>.</p></li>
<li><p>Evaluate <code class="docutils literal notranslate"><span class="pre">e'</span></code> to a value <code class="docutils literal notranslate"><span class="pre">v</span></code>, which is the result of evaluating
<code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span> <span class="pre">...</span> <span class="pre">en</span></code>.</p></li>
</ol>
<p>If you compare these evaluation rules to the rules for <code class="docutils literal notranslate"><span class="pre">let</span></code> expressions, you
will notice they both involve substitution. This is not an accident. In fact,
anywhere <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">e1</span> <span class="pre">in</span> <span class="pre">e2</span></code> appears in a program, we could replace it with
<code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e2)</span> <span class="pre">e1</span></code>. They are syntactically different but semantically
equivalent. In essence, <code class="docutils literal notranslate"><span class="pre">let</span></code> expressions are just syntactic sugar for anonymous
function application.</p>
</section>
<section id="pipeline">
<h2><span class="section-number">2.4.4. </span>Pipeline<a class="headerlink" href="#pipeline" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/arS9kEqCFEU" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>There is a built-in infix operator in OCaml for function application called the
<em>pipeline</em> operator, written <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code>. Imagine that as depicting a triangle pointing
to the right. The metaphor is that values are sent through the pipeline from
left to right. For example, suppose we have the increment function <code class="docutils literal notranslate"><span class="pre">inc</span></code> from
above as well as a function <code class="docutils literal notranslate"><span class="pre">square</span></code> that squares its input:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">square</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val square : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Here are two equivalent ways of squaring <code class="docutils literal notranslate"><span class="pre">6</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">square</span> <span class="o">(</span><span class="n">inc</span> <span class="mi">5</span><span class="o">);;</span>
<span class="mi">5</span> <span class="o">|&gt;</span> <span class="n">inc</span> <span class="o">|&gt;</span> <span class="n">square</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 36
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 36
</pre></div>
</div>
</div>
</div>
<p>The latter uses the pipeline operator to send <code class="docutils literal notranslate"><span class="pre">5</span></code> through the <code class="docutils literal notranslate"><span class="pre">inc</span></code> function,
then send the result of that through the <code class="docutils literal notranslate"><span class="pre">square</span></code> function. This is a nice,
idiomatic way of expressing the computation in OCaml. The former way is arguably
not as elegant: it involves writing extra parentheses and requires the reader’s
eyes to jump around, rather than move linearly from left to right. The latter
way scales up nicely when the number of functions being applied grows, whereas
the former way requires more and more parentheses:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">|&gt;</span> <span class="n">inc</span> <span class="o">|&gt;</span> <span class="n">square</span> <span class="o">|&gt;</span> <span class="n">inc</span> <span class="o">|&gt;</span> <span class="n">inc</span> <span class="o">|&gt;</span> <span class="n">square</span><span class="o">;;</span>
<span class="n">square</span> <span class="o">(</span><span class="n">inc</span> <span class="o">(</span><span class="n">inc</span> <span class="o">(</span><span class="n">square</span> <span class="o">(</span><span class="n">inc</span> <span class="mi">5</span><span class="o">))));;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1444
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1444
</pre></div>
</div>
</div>
</div>
<p>It might feel weird at first, but try using the pipeline operator in your own
code the next time you find yourself writing a big chain of function
applications.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">|&gt;</span> <span class="pre">e2</span></code> is just another way of writing <code class="docutils literal notranslate"><span class="pre">e2</span> <span class="pre">e1</span></code>, we don’t need to state
the semantics for <code class="docutils literal notranslate"><span class="pre">|&gt;</span></code>: it’s just the same as function application. These two
programs are another example of expressions that are syntactically different but
semantically equivalent.</p>
</section>
<section id="polymorphic-functions">
<h2><span class="section-number">2.4.5. </span>Polymorphic Functions<a class="headerlink" href="#polymorphic-functions" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/UWmxYBEKzN8" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The <em>identity</em> function is the function that simply returns its input:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id : &#39;a -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Or equivalently as an anonymous function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id : &#39;a -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">'a</span></code> is a <em>type variable</em>: it stands for an unknown type, just like a
regular variable stands for an unknown value. Type variables always begin with a
single quote. Commonly used type variables include <code class="docutils literal notranslate"><span class="pre">'a</span></code>, <code class="docutils literal notranslate"><span class="pre">'b</span></code>, and <code class="docutils literal notranslate"><span class="pre">'c</span></code>, which
OCaml programmers typically pronounce in Greek: alpha, beta, and gamma.</p>
<p>We can apply the identity function to any type of value we like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">id</span> <span class="mi">42</span><span class="o">;;</span>
<span class="n">id</span> <span class="bp">true</span><span class="o">;;</span>
<span class="n">id</span> <span class="s2">&quot;bigred&quot;</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 42
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : bool = true
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : string = &quot;bigred&quot;
</pre></div>
</div>
</div>
</div>
<p>Because you can apply <code class="docutils literal notranslate"><span class="pre">id</span></code> to many types of values, it is a <em>polymorphic</em>
function: it can be applied to many (<em>poly</em>) forms (<em>morph</em>).</p>
<p>With manual type annotations, it’s possible to give a more restrictive type
to a polymorphic function than the type the compiler automatically infers.
For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id_int</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="o">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id_int : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>That’s the same function as <code class="docutils literal notranslate"><span class="pre">id</span></code>, except for the two manual type annotations.
Because of those, we cannot apply <code class="docutils literal notranslate"><span class="pre">id_int</span></code> to a <code class="docutils literal notranslate"><span class="pre">bool</span></code> like we did <code class="docutils literal notranslate"><span class="pre">id</span></code>:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">id_int</span> <span class="bp">true</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s2">&quot;[14]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">7</span><span class="o">-</span><span class="mi">11</span><span class="p">:</span>
<span class="mi">1</span> <span class="o">|</span> <span class="n">id_int</span> <span class="n">true</span>
           <span class="o">^^^^</span>
<span class="ne">Error</span>: This expression has type bool but an expression was expected of type
         <span class="nb">int</span>
</pre></div>
</div>
</div>
</div>
<p>Another way of writing <code class="docutils literal notranslate"><span class="pre">id_int</span></code> would be in terms of <code class="docutils literal notranslate"><span class="pre">id</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id_int&#39;</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">id</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id_int&#39; : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>In effect, we took a value of type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code>, and we bound it to a name whose
type was manually specified as being <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. You might ask, why does that
work? They aren’t the same types, after all.</p>
<p>One way to think about this is in terms of <strong>behavior.</strong> The type of <code class="docutils literal notranslate"><span class="pre">id_int</span></code>
specifies one aspect of its behavior: given an <code class="docutils literal notranslate"><span class="pre">int</span></code> as input, it promises to
produce an <code class="docutils literal notranslate"><span class="pre">int</span></code> as output. It turns out that <code class="docutils literal notranslate"><span class="pre">id</span></code> also makes the same promise:
given an <code class="docutils literal notranslate"><span class="pre">int</span></code> as input, it too will return an <code class="docutils literal notranslate"><span class="pre">int</span></code> as output. Now <code class="docutils literal notranslate"><span class="pre">id</span></code> also
makes many more promises, such as: given a <code class="docutils literal notranslate"><span class="pre">bool</span></code> as input, it will return a
<code class="docutils literal notranslate"><span class="pre">bool</span></code> as output. So by binding <code class="docutils literal notranslate"><span class="pre">id</span></code> to a more restrictive type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>, we
have thrown away all those additional promises as irrelevant. Sure, that’s
information lost, but at least no promises will be broken.  It’s always
going to be safe to use a function of type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code> when what we needed
was a function of type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>.</p>
<p>The converse is not true. If we needed a function of type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code> but tried
to use a function of type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>, we’d be in trouble as soon as someone
passed an input of another type, such as <code class="docutils literal notranslate"><span class="pre">bool</span></code>. To prevent that trouble, OCaml
does something potentially surprising with the following code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id&#39;</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id&#39; : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">id'</span></code> is actually the increment function, not the identity function. So
passing it a <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">string</span></code> or some complicated data structure is not safe;
the only data <code class="docutils literal notranslate"><span class="pre">+</span></code> can safely manipulate are integers. OCaml therefore
<em>instantiates</em> the type variable <code class="docutils literal notranslate"><span class="pre">'a</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>, thus preventing us from
applying <code class="docutils literal notranslate"><span class="pre">id'</span></code> to non-integers:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">id&#39;</span> <span class="bp">true</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s2">&quot;[17]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">4</span><span class="o">-</span><span class="mi">8</span><span class="p">:</span>
<span class="mi">1</span> <span class="o">|</span> <span class="nb">id</span><span class="s1">&#39; true</span>
        <span class="o">^^^^</span>
<span class="ne">Error</span>: This expression has type bool but an expression was expected of type
         <span class="nb">int</span>
</pre></div>
</div>
</div>
</div>
<p>That leads us to another, more mechanical, way to think about all of this in
terms of <strong>application</strong>. By that we mean the very same notion of how a function
is applied to arguments: when evaluating the application <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">5</span></code>, the argument
<code class="docutils literal notranslate"><span class="pre">x</span></code> is <em>instantiated</em> with value <code class="docutils literal notranslate"><span class="pre">5</span></code>. Likewise, the <code class="docutils literal notranslate"><span class="pre">'a</span></code> in the type of <code class="docutils literal notranslate"><span class="pre">id</span></code> is
being instantiated with type <code class="docutils literal notranslate"><span class="pre">int</span></code> at that application. So if we write</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">id_int&#39;</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">id</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val id_int&#39; : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>we are in fact instantiating the <code class="docutils literal notranslate"><span class="pre">'a</span></code> in the type of <code class="docutils literal notranslate"><span class="pre">id</span></code> with the type <code class="docutils literal notranslate"><span class="pre">int</span></code>.
And just as there is no way to “unapply” a function—for example, given <code class="docutils literal notranslate"><span class="pre">5</span></code>
we can’t compute backwards to <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">5</span></code>—we can’t unapply that type
instantiation and change <code class="docutils literal notranslate"><span class="pre">int</span></code> back to <code class="docutils literal notranslate"><span class="pre">'a</span></code>.</p>
<p>To make that precise, suppose we have a <code class="docutils literal notranslate"><span class="pre">let</span></code> definition [or expression]:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span> <span class="o">[</span><span class="k">in</span> <span class="n">e&#39;</span><span class="o">]</span>
</pre></div>
</div>
<p>and that OCaml infers <code class="docutils literal notranslate"><span class="pre">x</span></code> has a type <code class="docutils literal notranslate"><span class="pre">t</span></code> that includes some type variables <code class="docutils literal notranslate"><span class="pre">'a</span></code>,
<code class="docutils literal notranslate"><span class="pre">'b</span></code>, etc. Then we are permitted to instantiate those type variables. We can do
that by applying the function to arguments that reveal what the type
instantiations should be (as in <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">5</span></code>) or by a type annotation (as in
<code class="docutils literal notranslate"><span class="pre">id_int'</span></code>), among other ways. But we have to be consistent with the
instantiation. For example, we cannot take a function of type <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'b</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code>
and instantiate it at type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">'b</span> <span class="pre">-&gt;</span> <span class="pre">string</span></code>, because the instantiation of
<code class="docutils literal notranslate"><span class="pre">'a</span></code> is not the same type in each of the two places it occurred:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">first</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">first_int</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">first</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">bad_first</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="n">first</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val first : &#39;a -&gt; &#39;b -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val first_int : int -&gt; &#39;b -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s2">&quot;[19]&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">38</span><span class="o">-</span><span class="mi">43</span><span class="p">:</span>
<span class="mi">3</span> <span class="o">|</span> <span class="n">let</span> <span class="n">bad_first</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="s1">&#39;b -&gt; string = first;;</span>
                                          <span class="o">^^^^^</span>
<span class="ne">Error</span>: This expression has type int -&gt; &#39;b -&gt; int
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="n">of</span> <span class="nb">type</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="s1">&#39;b -&gt; string</span>
       <span class="n">Type</span> <span class="nb">int</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="nb">type</span> <span class="n">string</span> 
</pre></div>
</div>
</div>
</div>
</section>
<section id="labeled-and-optional-arguments">
<h2><span class="section-number">2.4.6. </span>Labeled and Optional Arguments<a class="headerlink" href="#labeled-and-optional-arguments" title="Permalink to this heading">#</a></h2>
<p>The type and name of a function usually give you a pretty good idea of what the
arguments should be. However, for functions with many arguments (especially
arguments of the same type), it can be useful to label them. For example, you
might guess that the function <code class="docutils literal notranslate"><span class="pre">String.sub</span></code> returns a substring of the given
string (and you would be correct). You could type in <code class="docutils literal notranslate"><span class="pre">String.sub</span></code> to find its
type:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="nn">String</span><span class="p">.</span><span class="n">sub</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : string -&gt; int -&gt; int -&gt; string = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>But it’s not clear from the type how to use it—you’re forced to consult
the documentation.</p>
<p>OCaml supports labeled arguments to functions. You can declare this kind of
function using the following syntax:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">name1</span><span class="o">:</span><span class="n">arg1</span> <span class="o">~</span><span class="n">name2</span><span class="o">:</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val f : name1:int -&gt; name2:int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>This function can be called by passing the labeled arguments in either order:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">~</span><span class="n">name2</span><span class="o">:</span><span class="mi">3</span> <span class="o">~</span><span class="n">name1</span><span class="o">:</span><span class="mi">4</span>
</pre></div>
</div>
<p>Labels for arguments are often the same as the variable names for them. OCaml
provides a shorthand for this case. The following are equivalent:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">name1</span><span class="o">:</span><span class="n">name1</span> <span class="o">~</span><span class="n">name2</span><span class="o">:</span><span class="n">name2</span> <span class="o">=</span> <span class="n">name1</span> <span class="o">+</span> <span class="n">name2</span>
<span class="k">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">name1</span> <span class="o">~</span><span class="n">name2</span> <span class="o">=</span> <span class="n">name1</span> <span class="o">+</span> <span class="n">name2</span>
</pre></div>
</div>
<p>Use of labeled arguments is largely a matter of taste. They convey extra
information, but they can also add clutter to types.</p>
<p>The syntax to write both a labeled argument and an explicit type annotation for
it is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">name1</span><span class="p">:(</span><span class="n">arg1</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">~</span><span class="n">name2</span><span class="p">:(</span><span class="n">arg2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span>
</pre></div>
</div>
<p>It is also possible to make some arguments optional. When called without an
optional argument, a default value will be provided. To declare such a function,
use the following syntax:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">?</span><span class="n">name</span><span class="o">:(</span><span class="n">arg1</span><span class="o">=</span><span class="mi">8</span><span class="o">)</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val f : ?name:int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>You can then call a function with or without the argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">~</span><span class="n">name</span><span class="o">:</span><span class="mi">2</span> <span class="mi">7</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 9
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="mi">7</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 15
</pre></div>
</div>
</div>
</div>
</section>
<section id="partial-application">
<h2><span class="section-number">2.4.7. </span>Partial Application<a class="headerlink" href="#partial-application" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/85xVK0wmDTw" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>We could define an addition function as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val add : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Here’s a rather similar function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">addx</span> <span class="n">x</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val addx : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">addx</span></code> takes an integer <code class="docutils literal notranslate"><span class="pre">x</span></code> as input and returns a <em>function</em> of type
<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> that will add <code class="docutils literal notranslate"><span class="pre">x</span></code> to whatever is passed to it.</p>
<p>The type of <code class="docutils literal notranslate"><span class="pre">addx</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. The type of <code class="docutils literal notranslate"><span class="pre">add</span></code> is also
<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. So from the perspective of their types, they are the same
function. But the form of <code class="docutils literal notranslate"><span class="pre">addx</span></code> suggests something interesting: we can apply it
to just a single argument.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add5</span> <span class="o">=</span> <span class="n">addx</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val add5 : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">add5</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 7
</pre></div>
</div>
</div>
</div>
<p>It turns out the same can be done with <code class="docutils literal notranslate"><span class="pre">add</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add5</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val add5 : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">add5</span> <span class="mi">2</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 7
</pre></div>
</div>
</div>
</div>
<p>What we just did is called <em>partial application</em>: we partially applied the
function <code class="docutils literal notranslate"><span class="pre">add</span></code> to one argument, even though you would normally think of it as a
multi-argument function. This works because the following three functions are
<em>syntactically different</em> but <em>semantically equivalent</em>. That is, they are
different ways of expressing the same computation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">let</span> <span class="n">add</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</pre></div>
</div>
<p>So <code class="docutils literal notranslate"><span class="pre">add</span></code> is really a function that takes an argument <code class="docutils literal notranslate"><span class="pre">x</span></code> and returns a function
<code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y)</span></code>. Which leads us to a deep truth…</p>
</section>
<section id="function-associativity">
<h2><span class="section-number">2.4.8. </span>Function Associativity<a class="headerlink" href="#function-associativity" title="Permalink to this heading">#</a></h2>
<p>Are you ready for the truth?  Take a deep breath.  Here goes…</p>
<p><strong>Every OCaml function takes exactly one argument.</strong></p>
<p>Why? Consider <code class="docutils literal notranslate"><span class="pre">add</span></code>: although we can write it as <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">add</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, we know
that’s semantically equivalent to <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">add</span> <span class="pre">=</span> <span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">(fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y)</span></code>. And in
general,</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="n">x1</span> <span class="n">x2</span> <span class="o">...</span> <span class="n">xn</span> <span class="o">=</span> <span class="n">e</span>
</pre></div>
</div>
<p>is semantically equivalent to</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">x1</span> <span class="o">-&gt;</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">x2</span> <span class="o">-&gt;</span>
       <span class="o">(...</span>
          <span class="o">(</span><span class="k">fun</span> <span class="n">xn</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">)...))</span>
</pre></div>
</div>
<p>So even though you think of <code class="docutils literal notranslate"><span class="pre">f</span></code> as a function that takes <code class="docutils literal notranslate"><span class="pre">n</span></code> arguments, in
reality it is a function that takes 1 argument and returns a function.</p>
<p>The type of such a function</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">t3</span> <span class="o">-&gt;</span> <span class="n">t4</span>
</pre></div>
</div>
<p>really means the same as</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">t2</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">t3</span> <span class="o">-&gt;</span> <span class="n">t4</span><span class="o">))</span>
</pre></div>
</div>
<p>That is, function types are <em>right associative</em>: there are implicit parentheses
around function types, from right to left. The intuition here is that a function
takes a single argument and returns a new function that expects the remaining
arguments.</p>
<p>Function application, on the other hand, is <em>left associative</em>: there
are implicit parentheses around function applications, from left to right.
So</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span> <span class="n">e4</span>
</pre></div>
</div>
<p>really means the same as</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">((</span><span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">e3</span><span class="o">)</span> <span class="n">e4</span>
</pre></div>
</div>
<p>The intuition here is that the left-most expression grabs the next
expression to its right as its single argument.</p>
</section>
<section id="operators-as-functions">
<h2><span class="section-number">2.4.9. </span>Operators as Functions<a class="headerlink" href="#operators-as-functions" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/OVKOx8UiwxM" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>The addition operator <code class="docutils literal notranslate"><span class="pre">+</span></code> has type <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. It is normally written
<em>infix</em>, e.g., <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">4</span></code>. By putting parentheses around it, we can make it a
<em>prefix</em> operator:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">(</span> <span class="o">+</span> <span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">(</span> <span class="o">+</span> <span class="o">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 7
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="o">(</span> <span class="o">+</span> <span class="o">)</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val add3 : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">add3</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 5
</pre></div>
</div>
</div>
</div>
<p>The same technique works for any built-in operator.</p>
<p>Normally the spaces are unnecessary. We could write <code class="docutils literal notranslate"><span class="pre">(+)</span></code> or <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">+</span> <span class="pre">)</span></code>, but it is
best to include them. Beware of multiplication, which <em>must</em> be written as
<code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">*</span> <span class="pre">)</span></code>, because <code class="docutils literal notranslate"><span class="pre">(*)</span></code> would be parsed as beginning a comment.</p>
<p>We can even define our own new infix operators, for example:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="o">(</span> <span class="o">^^</span> <span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>
</div>
<p>And now <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">^^</span> <span class="pre">3</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<p>The rules for which punctuation can be used to create infix operators are not
necessarily intuitive. Nor is the relative precedence with which such operators
will be parsed. So be careful with this usage.</p>
</section>
<section id="tail-recursion">
<h2><span class="section-number">2.4.10. </span>Tail Recursion<a class="headerlink" href="#tail-recursion" title="Permalink to this heading">#</a></h2>
<p>Consider the following seemingly uninteresting function, which counts from 1 to
<code class="docutils literal notranslate"><span class="pre">n</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [count n] is [n], computed by adding 1 to itself [n] times.  That is,</span>
<span class="c">    this function counts up from 1 to [n]. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">count</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val count : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Counting to 10 is no problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 10
</pre></div>
</div>
</div>
</div>
<p>Counting to 100,000 is no problem either:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="mi">100_000</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 100000
</pre></div>
</div>
</div>
</div>
<p>But try counting to 1,000,000 and you’ll get the following error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Stack overflow during evaluation (looping recursion?).
</pre></div>
</div>
<p>What’s going on here?</p>
<p><strong>The Call Stack.</strong> The issue is that the <em>call stack</em> has a limited size. You
probably learned in one of your introductory programming classes that most
languages implement function calls with a stack. That stack contains one element
for each function call that has been started but has not yet completed. Each
element stores information like the values of local variables and which
instruction in the function is currently being executed. When the evaluation of
one function body calls another function, a new element is pushed on the call
stack, and it is popped off when the called function completes.</p>
<p>The size of the stack is usually limited by the operating system. So if the
stack runs out of space, it becomes impossible to make another function call.
Normally this doesn’t happen, because there’s no reason to make that many
successive function calls before returning. In cases where it does happen,
there’s good reason for the operating system to make that program stop: it might
be in the process of eating up <em>all</em> the memory available on the entire
computer, thus harming other programs running on the same computer. The <code class="docutils literal notranslate"><span class="pre">count</span></code>
function isn’t likely to do that, but this function would:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">count_forever</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count_forever</span> <span class="n">n</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val count_forever : &#39;a -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>So the operating system for safety’s sake limits the call stack size. That means
eventually <code class="docutils literal notranslate"><span class="pre">count</span></code> will run out of stack space on a large enough input. Notice
how that choice is really independent of the programming language. So this same
issue can and does occur in languages other than OCaml, including Python and
Java. You’re just less likely to have seen it manifest there, because you
probably never wrote quite as many recursive functions in those languages.</p>
<p><strong>Tail Recursion.</strong> There is a solution to this issue that was described in a
<a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/800179.810196">1977 paper about LISP by Guy Steele</a>. The solution, <em>tail-call
optimization</em>, requires some cooperation between the programmer and the
compiler. The programmer does a little rewriting of the function, which the
compiler then notices and applies an optimization. Let’s see how it works.</p>
<p>Suppose that a recursive function <code class="docutils literal notranslate"><span class="pre">f</span></code> calls itself then returns the result of
that recursive call. Our <code class="docutils literal notranslate"><span class="pre">count</span></code> function does <em>not</em> do that:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">count</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val count : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Rather, after the recursive call <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>, there is computation
remaining: the computer still needs to add <code class="docutils literal notranslate"><span class="pre">1</span></code> to the result of that call.</p>
<p>But we as programmers could rewrite the <code class="docutils literal notranslate"><span class="pre">count</span></code> function so that it does <em>not</em>
need to do any additional computation after the recursive call. The trick is
to create a helper function with an extra parameter:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">count_aux</span> <span class="n">n</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">count_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">count_tr</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count_aux</span> <span class="n">n</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val count_aux : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val count_tr : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">count_aux</span></code> is almost the same as our original <code class="docutils literal notranslate"><span class="pre">count</span></code>, but it adds an
extra parameter named <code class="docutils literal notranslate"><span class="pre">acc</span></code>, which is idiomatic and stands for “accumulator”.
The idea is that the value we want to return from the function is slowly, with
each recursive call, being accumulated in it. The “remaining computation”
—the addition of 1— now happens <em>before</em> the recursive call not
<em>after</em>.  When the base case of the recursion finally arrives, the function
now returns <code class="docutils literal notranslate"><span class="pre">acc</span></code>, where the answer has been accumulated.</p>
<p>But the original base case of 0 still needs to exist in the code somewhere.
And it does, as the original value of <code class="docutils literal notranslate"><span class="pre">acc</span></code> that is passed to <code class="docutils literal notranslate"><span class="pre">count_aux</span></code>.
Now <code class="docutils literal notranslate"><span class="pre">count_tr</span></code> (we’ll get to why the name is “tr” in just a minute) works
as a replacement for our original <code class="docutils literal notranslate"><span class="pre">count</span></code>.</p>
<p>At this point we’ve completed the programmer’s responsibility, but it’s probably
not clear why we went through this effort. After all <code class="docutils literal notranslate"><span class="pre">count_aux</span></code> will still call
itself recursively too many times as <code class="docutils literal notranslate"><span class="pre">count</span></code> did, and eventually overflow the
stack.</p>
<p>That’s where the compiler’s responsibility kicks in. A good compiler (and the
OCaml compiler is good this way) can notice when a recursive call is in <em>tail
position</em>, which is a technical way of saying “there’s no more computation to be
done after it returns”. The recursive call to <code class="docutils literal notranslate"><span class="pre">count_aux</span></code> is in tail position;
the recursive call to <code class="docutils literal notranslate"><span class="pre">count</span></code> is not. Here they are again so you can compare
them:</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">count</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">count_aux</span> <span class="n">n</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">count_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s why tail position matters: <strong>A recursive call in tail position does not
need a new stack frame. It can just reuse the existing stack frame.</strong> That’s
because there’s nothing left of use in the existing stack frame! There’s no
computation left to be done, so none of the local variables, or next instruction
to execute, etc. matter any more. None of that memory ever needs to be read
again, because that call is effectively already finished. So instead of wasting
space by allocating another stack frame, the compiler “recycles” the space used
by the previous frame.</p>
<p>This is the <em>tail-call optimization</em>. It can even be applied in cases beyond
recursive functions if the calling function’s stack frame is suitably compatible
with the callee. And, it’s a big deal. The tail-call optimization reduces the
stack space requirements from linear to constant. Whereas <code class="docutils literal notranslate"><span class="pre">count</span></code> needed <span class="math notranslate nohighlight">\(O(n)\)</span>
stack frames, <code class="docutils literal notranslate"><span class="pre">count_aux</span></code> needs only <span class="math notranslate nohighlight">\(O(1)\)</span>, because the same frame gets reused
over and over again for each recursive call. And that means <code class="docutils literal notranslate"><span class="pre">count_tr</span></code> actually
can count to 1,000,000:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">count_tr</span> <span class="mi">1_000_000</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = 1000000
</pre></div>
</div>
</div>
</div>
<p>Finally, why did we name this function <code class="docutils literal notranslate"><span class="pre">count_tr</span></code>? The “tr” stands for <em>tail
recursive</em>. A tail recursive function is a recursive function whose recursive
calls are all in tail position. In other words, it’s a function that (unless
there are other pathologies) will not exhaust the stack.</p>
<p><strong>The Importance of Tail Recursion.</strong> Sometimes beginning functional programmers
fixate a bit too much upon it. If all you care about is writing the first draft
of a function, you probably don’t need to worry about tail recursion. It’s
pretty easy to make it tail recursive later if you need to, just by adding an
accumulator argument. Or maybe you should rethink how you have designed the
function. Take <code class="docutils literal notranslate"><span class="pre">count</span></code>, for example: it’s kind of dumb. But later we’ll see
examples that aren’t dumb, such as iterating over lists with thousands of
elements.</p>
<p>It is important that the compiler support the optimization. Otherwise, the
transformation you do to the code as a programmer makes no difference. Indeed,
most compilers do support it, at least as an option. Java is a notable
exception.</p>
<p><strong>The Recipe for Tail Recursion.</strong> In a nutshell, here’s how we made a function
be tail recursive:</p>
<ol class="arabic simple">
<li><p>Change the function into a helper function. Add an extra argument: the
accumulator, often named <code class="docutils literal notranslate"><span class="pre">acc</span></code>.</p></li>
<li><p>Write a new “main” version of the function that calls the helper. It passes
the original base case’s return value as the initial value of the
accumulator.</p></li>
<li><p>Change the helper function to return the accumulator in the base case.</p></li>
<li><p>Change the helper function’s recursive case. It now needs to do the extra
work on the accumulator argument, before the recursive call. This is the only
step that requires much ingenuity.</p></li>
</ol>
<p><strong>An Example: Factorial.</strong> Let’s transform this factorial function to be
tail recursive:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="c">(** [fact n] is [n] factorial. *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">fact</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>First, we change its name and add an accumulator argument:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fact_aux</span> <span class="n">n</span> <span class="n">acc</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Second, we write a new “main” function that calls the helper with the original
base case as the accumulator:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">fact_tr</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fact_aux</span> <span class="n">n</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Third, we change the helper function to return the accumulator in the base case:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">acc</span> <span class="o">...</span>
</pre></div>
</div>
<p>Finally, we change the recursive case:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">else</span> <span class="n">fact_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="o">)</span>
</pre></div>
</div>
<p>Putting it all together, we have:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fact_aux</span> <span class="n">n</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">fact_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="o">)</span>

<span class="k">let</span> <span class="n">fact_tr</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fact_aux</span> <span class="n">n</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact_aux : int -&gt; int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fact_tr : int -&gt; int = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>It was a nice exercise, but maybe not worthwhile.  Even before we exhaust the
stack space, the computation suffers from integer overflow:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="n">fact</span> <span class="mi">50</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : int = -3258495067890909184
</pre></div>
</div>
</div>
</div>
<p>To solve that problem, we turn to OCaml’s big integer library,
<a class="reference external" href="https://antoinemine.github.io/Zarith/doc/latest/Z.html">Zarith</a>. Here we use a few OCaml features that are beyond anything
we’ve seen so far, but hopefully nothing terribly surprising. (If you want to
follow along with this code, first install Zarith in OPAM with
<code class="docutils literal notranslate"><span class="pre">opam</span> <span class="pre">install</span> <span class="pre">zarith</span></code>.)</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span><span class="n">require</span> <span class="s2">&quot;zarith.top&quot;</span><span class="o">;;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">zfact_aux</span> <span class="n">n</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="k">if</span> <span class="nn">Z</span><span class="p">.</span><span class="n">equal</span> <span class="n">n</span> <span class="nn">Z</span><span class="p">.</span><span class="n">zero</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">zfact_aux</span> <span class="o">(</span><span class="nn">Z</span><span class="p">.</span><span class="n">pred</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="nn">Z</span><span class="p">.</span><span class="n">mul</span> <span class="n">acc</span> <span class="n">n</span><span class="o">);;</span>

<span class="k">let</span> <span class="n">zfact_tr</span> <span class="n">n</span> <span class="o">=</span> <span class="n">zfact_aux</span> <span class="n">n</span> <span class="nn">Z</span><span class="p">.</span><span class="n">one</span><span class="o">;;</span>

<span class="n">zfact_tr</span> <span class="o">(</span><span class="nn">Z</span><span class="p">.</span><span class="n">of_int</span> <span class="mi">50</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val zfact_aux : Z.t -&gt; Z.t -&gt; Z.t = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val zfact_tr : Z.t -&gt; Z.t = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>- : Z.t = 30414093201713378043612608166064768844377641568960512000000000000
</pre></div>
</div>
</div>
</div>
<p>If you want you can use that code to compute <code class="docutils literal notranslate"><span class="pre">zfact_tr</span> <span class="pre">1_000_000</span></code> without stack
or integer overflow, though it will take several minutes.</p>
<p>The chapter on modules will explain the OCaml features we used above in detail,
but for now:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">#require</span></code> loads the library, which provides a module named <code class="docutils literal notranslate"><span class="pre">Z</span></code>. Recall that
<span class="math notranslate nohighlight">\(\mathbb{Z}\)</span> is the symbol used in mathematics to denote the integers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Z.n</span></code> means the name <code class="docutils literal notranslate"><span class="pre">n</span></code> defined inside of <code class="docutils literal notranslate"><span class="pre">Z</span></code>.</p></li>
<li><p>The type <code class="docutils literal notranslate"><span class="pre">Z.t</span></code> is the library’s name for the type of big integers.</p></li>
<li><p>We use library values <code class="docutils literal notranslate"><span class="pre">Z.equal</span></code> for equality comparison, <code class="docutils literal notranslate"><span class="pre">Z.zero</span></code> for 0,
<code class="docutils literal notranslate"><span class="pre">Z.pred</span></code> for predecessor (i.e., subtracting 1), <code class="docutils literal notranslate"><span class="pre">Z.mul</span></code> for multiplication,
<code class="docutils literal notranslate"><span class="pre">Z.one</span></code> for 1, and <code class="docutils literal notranslate"><span class="pre">Z.of_int</span></code> to convert a primitive integer to a big integer.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "cs3110/textbook",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "ocaml-jupyter"
        },
        kernelOptions: {
            name: "ocaml-jupyter",
            path: "./chapters/basics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'ocaml-jupyter'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="expressions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">2.3. </span>Expressions</p>
      </div>
    </a>
    <a class="right-next"
       href="documentation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2.5. </span>Documentation</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-definitions">2.4.1. Function Definitions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#anonymous-functions">2.4.2. Anonymous Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-application">2.4.3. Function Application</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pipeline">2.4.4. Pipeline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#polymorphic-functions">2.4.5. Polymorphic Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#labeled-and-optional-arguments">2.4.6. Labeled and Optional Arguments</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-application">2.4.7. Partial Application</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-associativity">2.4.8. Function Associativity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operators-as-functions">2.4.9. Operators as Functions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tail-recursion">2.4.10. Tail Recursion</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Michael R. Clarkson et al.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>