

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>8.8. Structural Induction &#8212; OCaml Programming: Correct + Efficient + Beautiful</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=bd9e20870c6007c4c509" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=bd9e20870c6007c4c509"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/correctness/structural_induction';</script>
    <link rel="shortcut icon" href="../../_static/op.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8.9. Equational Specification" href="eq_spec.html" />
    <link rel="prev" title="8.7. Proving Correctness" href="proving_correctness.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <header>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">Using this book as part of a course? Please <a style="color:white" href="https://docs.google.com/forms/d/e/1FAIpQLSfEW65AJPBnk732zZZM9CFpWMobWUkym6Nf-pgslRqqwoWYIA/viewform?usp=preview">let us know</a>!</div>
  </div>

  
    <div class="bd-header navbar navbar-expand-lg bd-navbar">
    </div>
  
  </header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../cover.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/op_title.png" class="logo__image only-light" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>
    <script>document.write(`<img src="../../_static/op_title.png" class="logo__image only-dark" alt="OCaml Programming: Correct + Efficient + Beautiful - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Preface</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../preface/about.html">About This Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface/install.html">Installing OCaml</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../intro/intro.html">1. Better Programming Through OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro/past.html">1.1. The Past of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/present.html">1.2. The Present of OCaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/future.html">1.3. Look to Your Future</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/3110.html">1.4. A Brief History of CS 3110</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro/summary.html">1.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../basics/intro.html">2. The Basics of OCaml</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../basics/toplevel.html">2.1. The OCaml Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/compiling.html">2.2. Compiling OCaml Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/expressions.html">2.3. Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/functions.html">2.4. Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/documentation.html">2.5. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/printing.html">2.6. Printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/debugging.html">2.7. Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/summary.html">2.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics/exercises.html">2.9. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">OCaml Programming</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../data/intro.html">3. Data and Types</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data/lists.html">3.1. Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/variants.html">3.2. Variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/ounit.html">3.3. Unit Testing with OUnit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/records_tuples.html">3.4. Records and Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/pattern_matching_advanced.html">3.5. Advanced Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/type_synonym.html">3.6. Type Synonyms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/options.html">3.7. Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/assoc_list.html">3.8. Association Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/algebraic_data_types.html">3.9. Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exceptions.html">3.10. Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/trees.html">3.11. Example: Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/nats.html">3.12. Example: Natural Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/summary.html">3.13. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data/exercises.html">3.14. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../hop/intro.html">4. Higher-Order Programming</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../hop/higher_order.html">4.1. Higher-Order Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/map.html">4.2. Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/filter.html">4.3. Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/fold.html">4.4. Fold</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/beyond_lists.html">4.5. Beyond Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/pipelining.html">4.6. Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/currying.html">4.7. Currying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/summary.html">4.8. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hop/exercises.html">4.9. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../modules/intro.html">5. Modular Programming</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_systems.html">5.1. Module Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/modules.html">5.2. Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/toplevel.html">5.3. Modules and the Toplevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/encapsulation.html">5.4. Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/compilation_units.html">5.5. Compilation Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functional_data_structures.html">5.6. Functional Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/module_type_constraints.html">5.7. Module Type Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/includes.html">5.8. Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/functors.html">5.9. Functors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/summary.html">5.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/exercises.html">5.11. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mut/intro.html">6. Mutability</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mut/refs.html">6.1. Refs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/mutable_fields.html">6.2. Mutable Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/arrays.html">6.3. Arrays and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/summary.html">6.4. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mut/exercises.html">6.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../conc/intro.html">7. Concurrency</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../conc/concurrency.html">7.1. Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/promises.html">7.2. Promises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/impl_promises.html">7.3. Implementing Promises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/io_promises.html">7.4. Asynchronous Input and Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/callbacks.html">7.5. Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/impl_callbacks.html">7.6. Implementing Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/full_promises_impl.html">7.7. The Full Promises Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/monads.html">7.8. Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/summary.html">7.9. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conc/exercises.html">7.10. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Correctness and Efficiency</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active has-children"><a class="reference internal" href="intro.html">8. Correctness</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="specifications.html">8.1. Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="function_docs.html">8.2. Function Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="module_docs.html">8.3. Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="test_debug.html">8.4. Testing and Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="black_glass_box.html">8.5. Black-box and Glass-box Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="randomized.html">8.6. Randomized Testing with QCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="proving_correctness.html">8.7. Proving Correctness</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.8. Structural Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="eq_spec.html">8.9. Equational Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">8.10. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="exercises.html">8.11. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../ds/intro.html">9. Data Structures</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../ds/hash_tables.html">9.1. Hash Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/amortized.html">9.2. Amortized Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/rb.html">9.3. Red-Black Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/sequence.html">9.4. Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/memoization.html">9.5. Memoization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/parrays.html">9.6. Persistent Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/summary.html">9.7. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ds/exercises.html">9.8. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Language Implementation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../interp/intro.html">10. Interpreters</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../interp/calculator.html">10.1. Example: Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/parsing.html">10.2. Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/substitution.html">10.3. Substitution Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/environment.html">10.4. Environment Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/typecheck.html">10.5. Type Checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/inference.html">10.6. Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/summary.html">10.7. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interp/exercises.html">10.8. Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lagniappe</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../adv/curry-howard.html">The Curry-Howard Correspondence</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix/bigoh.html">Big-Oh Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/vm.html">Virtual Machine</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/cs3110/textbook/main?urlpath=tree/src/chapters/correctness/structural_induction.md" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/cs3110/textbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/edit/main/src/chapters/correctness/structural_induction.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/cs3110/textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/correctness/structural_induction.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chapters/correctness/structural_induction.ipynb" target="_blank"
   class="btn btn-sm btn-download-notebook-button dropdown-item"
   title="Download notebook file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li><a href="../../_sources/chapters/correctness/structural_induction.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Structural Induction</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-naturals">8.8.1. Induction on Naturals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-lists">8.8.2. Induction on Lists</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-theorem-about-folding">8.8.3. A Theorem about Folding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-trees">8.8.4. Induction on Trees</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-principles-for-all-variants">8.8.5. Induction Principles for All Variants</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-and-recursion">8.8.6. Induction and Recursion</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="structural-induction">
<h1><span class="section-number">8.8. </span>Structural Induction<a class="headerlink" href="#structural-induction" title="Permalink to this heading">#</a></h1>
<p>So far we’ve proved the correctness of recursive functions on natural numbers.
We can do correctness proofs about recursive functions on variant types, too.
That requires us to figure out how induction works on variants. We’ll do that,
next, starting with a variant type for representing natural numbers, then
generalizing to lists, trees, and other variants. This inductive proof technique
is sometimes known as <em>structural induction</em> instead of <em>mathematical
induction</em>. But that’s just a piece of vocabulary; don’t get hung up on it. The
core idea is completely the same.</p>
<section id="induction-on-naturals">
<h2><span class="section-number">8.8.1. </span>Induction on Naturals<a class="headerlink" href="#induction-on-naturals" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/Lkb-eTUrHTs" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>We used OCaml’s <code class="docutils literal notranslate"><span class="pre">int</span></code> type as a representation of the naturals. Of course, that
type is somewhat of a mismatch: negative <code class="docutils literal notranslate"><span class="pre">int</span></code> values don’t represent naturals,
and there is an upper bound to what natural numbers we can represent with <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>Let’s fix those problems by defining our own variant to represent natural
numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">nat</span> <span class="o">=</span> <span class="nc">Z</span> <span class="o">|</span> <span class="nc">S</span> <span class="k">of</span> <span class="n">nat</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type nat = Z | S of nat
</pre></div>
</div>
</div>
</div>
<p>The constructor <code class="docutils literal notranslate"><span class="pre">Z</span></code> represents zero; and the constructor <code class="docutils literal notranslate"><span class="pre">S</span></code> represents the
successor of another natural number. So,</p>
<ul class="simple">
<li><p>0 is represented by <code class="docutils literal notranslate"><span class="pre">Z</span></code>,</p></li>
<li><p>1 by <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">Z</span></code>,</p></li>
<li><p>2 by <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">(S</span> <span class="pre">Z)</span></code>,</p></li>
<li><p>3 by <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">(S</span> <span class="pre">(S</span> <span class="pre">Z))</span></code>,</p></li>
</ul>
<p>and so forth. This variant is thus a <em>unary</em> (as opposed to binary or decimal)
representation of the natural numbers: the number of times <code class="docutils literal notranslate"><span class="pre">S</span></code> occurs in a value
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code> is the natural number that <code class="docutils literal notranslate"><span class="pre">n</span></code> represents.</p>
<p>We can define addition on natural numbers with the following function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">plus</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Z</span> <span class="o">-&gt;</span> <span class="n">b</span>
  <span class="o">|</span> <span class="nc">S</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="nc">S</span> <span class="o">(</span><span class="n">plus</span> <span class="n">k</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val plus : nat -&gt; nat -&gt; nat = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Immediately we can prove the following rather trivial claim:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Claim:  plus Z n = n

Proof:

  plus Z n
=   { evaluation }
  n

QED
</pre></div>
</div>
<p>But suppose we want to prove this also trivial-seeming claim:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Claim:  plus n Z = n

Proof:

  plus n Z
=
  ???
</pre></div>
</div>
<p>We can’t just evaluate <code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">n</span> <span class="pre">Z</span></code>, because <code class="docutils literal notranslate"><span class="pre">plus</span></code> matches against its first
argument, not second. One possibility would be to do a case analysis: what if
<code class="docutils literal notranslate"><span class="pre">n</span></code> is <code class="docutils literal notranslate"><span class="pre">Z</span></code>, vs. <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">k</span></code> for some <code class="docutils literal notranslate"><span class="pre">k</span></code>? Let’s attempt that.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Proof:

By case analysis on n, which must be either Z or S k.

Case:  n = Z

  plus Z Z
=   { evaluation }
  Z

Case:  n = S k

  plus (S k) Z
=   { evaluation }
  S (plus k Z)
=
  ???
</pre></div>
</div>
<p>We are again stuck, and for the same reason: once more <code class="docutils literal notranslate"><span class="pre">plus</span></code> can’t be evaluated
any further.</p>
<p>When you find yourself needing to solve the same subproblem in programming, you
use recursion. When it happens in a proof, you use induction!</p>
<p>We’ll need an induction principle for <code class="docutils literal notranslate"><span class="pre">nat</span></code>. Here it is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall properties P,
  if P(Z),
  and if forall k, P(k) implies P(S k),
  then forall n, P(n)
</pre></div>
</div>
<p>Compare that to the induction principle we used for natural numbers before,
when we were using <code class="docutils literal notranslate"><span class="pre">int</span></code> in place of natural numbers:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall properties P,
  if P(0),
  and if forall k, P(k) implies P(k + 1),
  then forall n, P(n)
</pre></div>
</div>
<p>There’s no essential difference between the two: we just use <code class="docutils literal notranslate"><span class="pre">Z</span></code> in place of
<code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">k</span></code> in place of <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
<p>Using that induction principle, we can carry out the proof:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Claim:  plus n Z = n

Proof: by induction on n.
P(n) = plus n Z = n

Base case: n = Z
Show: plus Z Z = Z

  plus Z Z
=   { evaluation }
  Z

Inductive case: n = S k
IH: plus k Z = k
Show: plus (S k) Z = S k

  plus (S k) Z
=   { evaluation }
  S (plus k Z)
=   { IH }
  S k

QED
</pre></div>
</div>
</section>
<section id="induction-on-lists">
<h2><span class="section-number">8.8.2. </span>Induction on Lists<a class="headerlink" href="#induction-on-lists" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/Xo3rW_dTqEg" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>It turns out that natural numbers and lists are quite similar, when viewed
as data types.  Here are the definitions of both, aligned for comparison:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span>    <span class="n">nat</span>  <span class="o">=</span> <span class="nc">Z</span>  <span class="o">|</span> <span class="nc">S</span>      <span class="k">of</span> <span class="n">nat</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">(</span> <span class="o">::</span> <span class="o">)</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>
</pre></div>
</div>
<p>Both types have a constructor representing a concept of “nothing”. Both types
also have a constructor representing “one more” than another value of the type:
<code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code> is one more than <code class="docutils literal notranslate"><span class="pre">n</span></code>, and <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">::</span> <span class="pre">t</span></code> is a list with one more element than
<code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>The induction principle for lists is likewise quite similar to the induction
principle for natural numbers. Here is the principle for lists:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall properties P,
  if P([]),
  and if forall h t, P(t) implies P(h :: t),
  then forall lst, P(lst)
</pre></div>
</div>
<p>An inductive proof for lists therefore has the following structure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Proof: by induction on lst.
P(lst) = ...

Base case: lst = []
Show: P([])

Inductive case: lst = h :: t
IH: P(t)
Show: P(h :: t)
</pre></div>
</div>
<p>Let’s try an example of this kind of proof. Recall the definition of the append
operator:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">append</span> <span class="n">lst1</span> <span class="n">lst2</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst1</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">lst2</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">::</span> <span class="n">append</span> <span class="n">t</span> <span class="n">lst2</span>

<span class="k">let</span> <span class="o">(</span> <span class="o">@</span> <span class="o">)</span> <span class="o">=</span> <span class="n">append</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val append : &#39;a list -&gt; &#39;a list -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val ( @ ) : &#39;a list -&gt; &#39;a list -&gt; &#39;a list = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>We’ll prove that append is associative.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Theorem: forall xs ys zs, xs @ (ys @ zs) = (xs @ ys) @ zs

Proof: by induction on xs.
P(xs) = forall ys zs, xs @ (ys @ zs) = (xs @ ys) @ zs

Base case: xs = []
Show: forall ys zs, [] @ (ys @ zs) = ([] @ ys) @ zs

  [] @ (ys @ zs)
=   { evaluation }
  ys @ zs
=   { evaluation }
  ([] @ ys) @ zs

Inductive case: xs = h :: t
IH: forall ys zs, t @ (ys @ zs) = (t @ ys) @ zs
Show: forall ys zs, (h :: t) @ (ys @ zs) = ((h :: t) @ ys) @ zs

  (h :: t) @ (ys @ zs)
=   { evaluation }
  h :: (t @ (ys @ zs))
=   { IH }
  h :: ((t @ ys) @ zs)

  ((h :: t) @ ys) @ zs
=   { evaluation of inner @ }
  (h :: (t @ ys)) @ zs
=   { evaluation of outer @ }
  h :: ((t @ ys) @ zs)

QED
</pre></div>
</div>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/4B2jF2zHSCs" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
</section>
<section id="a-theorem-about-folding">
<h2><span class="section-number">8.8.3. </span>A Theorem about Folding<a class="headerlink" href="#a-theorem-about-folding" title="Permalink to this heading">#</a></h2>
<p>When we studied <code class="docutils literal notranslate"><span class="pre">List.fold_left</span></code> and <code class="docutils literal notranslate"><span class="pre">List.fold_right</span></code>, we discussed how they
sometimes compute the same function, but in general do not. For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">List</span><span class="o">.</span><span class="n">fold_left</span> <span class="p">(</span> <span class="o">+</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">=</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="o">=</span> <span class="mi">6</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">))</span>
<span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="n">fold_right</span> <span class="p">(</span> <span class="o">+</span> <span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span>
</pre></div>
</div>
<p>but</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">List</span><span class="o">.</span><span class="n">fold_left</span> <span class="p">(</span> <span class="o">-</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">=</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
<span class="o">=</span> <span class="o">-</span><span class="mi">6</span>
<span class="o">&lt;&gt;</span> <span class="mi">2</span>
<span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">0</span><span class="p">))</span>
<span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="n">fold_right</span> <span class="p">(</span> <span class="o">-</span> <span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Based on the equations above, it looks like the fact that <code class="docutils literal notranslate"><span class="pre">+</span></code> is commutative and
associative, whereas <code class="docutils literal notranslate"><span class="pre">-</span></code> is not, explains this difference between when the two
fold functions get the same answer. Let’s prove it!</p>
<p>First, recall the definitions of the fold functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="n">acc</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">acc</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">acc</span> <span class="n">h</span><span class="o">)</span> <span class="n">t</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="n">f</span> <span class="n">lst</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">acc</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">h</span> <span class="o">(</span><span class="n">fold_right</span> <span class="n">f</span> <span class="n">t</span> <span class="n">acc</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fold_left : (&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;b list -&gt; &#39;a = &lt;fun&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val fold_right : (&#39;a -&gt; &#39;b -&gt; &#39;b) -&gt; &#39;a list -&gt; &#39;b -&gt; &#39;b = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>Second, recall what it means for a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">'a</span> <span class="pre">-&gt;</span> <span class="pre">'a</span></code> to be commutative and
associative:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Commutative:  forall x y, f x y = f y x
Associative:  forall x y z, f x (f y z) = f (f x y) z
</pre></div>
</div>
<p>Those might look a little different than the normal formulations of those
properties, because we are using <code class="docutils literal notranslate"><span class="pre">f</span></code> as a prefix operator. If we were to write
<code class="docutils literal notranslate"><span class="pre">f</span></code> instead as an infix operator <code class="docutils literal notranslate"><span class="pre">op</span></code>, they would look more familiar:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Commutative:  forall x y, x op y = y op x
Associative:  forall x y z, x op (y op z) = (x op y) op z
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">f</span></code> is both commutative and associative we have this little interchange
lemma that lets us swap two arguments around:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Lemma</span> <span class="p">(</span><span class="n">interchange</span><span class="p">):</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">y</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span>

<span class="n">Proof</span><span class="p">:</span>

  <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span>
<span class="o">=</span>   <span class="p">{</span> <span class="n">associativity</span> <span class="p">}</span>
  <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">z</span>
<span class="o">=</span>   <span class="p">{</span> <span class="n">commutativity</span> <span class="p">}</span>
  <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">x</span><span class="p">)</span> <span class="n">z</span>
<span class="o">=</span>   <span class="p">{</span> <span class="n">associativity</span> <span class="p">}</span>
  <span class="n">f</span> <span class="n">y</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">z</span><span class="p">)</span>

<span class="n">QED</span>
</pre></div>
</div>
<p>Now we’re ready to state and prove the theorem.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Theorem: If f is commutative and associative, then
  forall lst acc,
    fold_left f acc lst = fold_right f lst acc.

Proof: by induction on lst.
P(lst) = forall acc,
  fold_left f acc lst = fold_right f lst acc

Base case: lst = []
Show: forall acc,
  fold_left f acc [] = fold_right f [] acc

  fold_left f acc []
=   { evaluation }
  acc
=   { evaluation }
  fold_right f [] acc

Inductive case: lst = h :: t
IH: forall acc,
  fold_left f acc t = fold_right f t acc
Show: forall acc,
  fold_left f acc (h :: t) = fold_right f (h :: t) acc

  fold_left f acc (h :: t)
=   { evaluation }
  fold_left f (f acc h) t
=   { IH with acc := f acc h }
  fold_right f t (f acc h)

  fold_right f (h :: t) acc
=   { evaluation }
  f h (fold_right f t acc)
</pre></div>
</div>
<p>Now, it might seem as though we are stuck: the left and right sides of the
equality we want to show have failed to “meet in the middle.” But we’re actually
in a similar situation to when we proved the correctness of <code class="docutils literal notranslate"><span class="pre">facti</span></code> earlier:
there’s something (applying <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">h</span></code> and another argument) that we want to
push into the accumulator of that last line (so that we have <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">acc</span> <span class="pre">h</span></code>).</p>
<p>Let’s try proving that with its own lemma:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Lemma: forall lst acc x,
  f x (fold_right f lst acc) = fold_right f lst (f acc x)

Proof: by induction on lst.
P(lst) = forall acc x,
  f x (fold_right f lst acc) = fold_right f lst (f acc x)

Base case: lst = []
Show: forall acc x,
  f x (fold_right f [] acc) = fold_right f [] (f acc x)

  f x (fold_right f [] acc)
=   { evaluation }
  f x acc

  fold_right f [] (f acc x)
=   { evaluation }
  f acc x
=   { commutativity of f }
  f x acc

Inductive case: lst = h :: t
IH: forall acc x,
  f x (fold_right f t acc) = fold_right f t (f acc x)
Show: forall acc x,
  f x (fold_right f (h :: t) acc) = fold_right f (h :: t) (f acc x)

  f x (fold_right f (h :: t) acc)
=  { evaluation }
  f x (f h (fold_right f t acc))
=  { interchange lemma }
  f h (f x (fold_right f t acc))
=  { IH }
  f h (fold_right f t (f acc x))

  fold_right f (h :: t) (f acc x)
=   { evaluation }
  f h (fold_right f t (f acc x))

QED
</pre></div>
</div>
<p>Now that the lemma is completed, we can resume the proof of the theorem. We’ll
restart at the beginning of the inductive case:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Inductive case: lst = h :: t
IH: forall acc,
  fold_left f acc t = fold_right f t acc
Show: forall acc,
  fold_left f acc (h :: t) = fold_right f (h :: t) acc

  fold_left f acc (h :: t)
=   { evaluation }
  fold_left f (f acc h) t
=   { IH with acc := f acc h }
  fold_right f t (f acc h)

  fold_right f (h :: t) acc
=   { evaluation }
  f h (fold_right f t acc)
=   { lemma with x := h and lst := t }
  fold_right f t (f acc h)

QED
</pre></div>
</div>
<p>It took two inductions to prove the theorem, but we succeeded! Now we know that
the behavior we observed with <code class="docutils literal notranslate"><span class="pre">+</span></code> wasn’t a fluke: any commutative and
associative operator causes <code class="docutils literal notranslate"><span class="pre">fold_left</span></code> and <code class="docutils literal notranslate"><span class="pre">fold_right</span></code> to get the same answer.</p>
</section>
<section id="induction-on-trees">
<h2><span class="section-number">8.8.4. </span>Induction on Trees<a class="headerlink" href="#induction-on-trees" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/UJyE8ylHFA0" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Lists and binary trees are similar when viewed as data types.  Here are the
definitions of both, aligned for comparison:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>   <span class="o">|</span> <span class="o">(</span> <span class="o">::</span> <span class="o">)</span> <span class="k">of</span>           <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span>   <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a list = [] | (::) of &#39;a * &#39;a list
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type &#39;a tree = Leaf | Node of &#39;a tree * &#39;a * &#39;a tree
</pre></div>
</div>
</div>
</div>
<p>Both have a constructor that represents “empty”, and both have a constructor
that combines a value of type <code class="docutils literal notranslate"><span class="pre">'a</span></code> together with another instance of the
data type.  The only real difference is that <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">::</span> <span class="pre">)</span></code> takes just <em>one</em> list,
whereas <code class="docutils literal notranslate"><span class="pre">Node</span></code> takes <em>two</em> trees.</p>
<p>The induction principle for binary trees is therefore very similar to the
induction principle for lists, except that with binary trees we get
<em>two</em> inductive hypotheses, one for each subtree:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall properties P,
  if P(Leaf),
  and if forall l v r, (P(l) and P(r)) implies P(Node (l, v, r)),
  then forall t, P(t)
</pre></div>
</div>
<p>An inductive proof for binary trees therefore has the following structure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Proof: by induction on t.
P(t) = ...

Base case: t = Leaf
Show: P(Leaf)

Inductive case: t = Node (l, v, r)
IH1: P(l)
IH2: P(r)
Show: P(Node (l, v, r))
</pre></div>
</div>
<p>Let’s try an example of this kind of proof. Here is a function that creates the
mirror image of a tree, swapping its left and right subtrees at all levels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">reflect</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">reflect</span> <span class="n">r</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">reflect</span> <span class="n">l</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>val reflect : &#39;a tree -&gt; &#39;a tree = &lt;fun&gt;
</pre></div>
</div>
</div>
</div>
<p>For example, these two trees are reflections of each other:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>     1               1
   /   \           /   \
  2     3         3     2
 / \   / \       / \   / \
4   5 6   7     7   6 5   4
</pre></div>
</div>
<p>If you take the mirror image of a mirror image, you should get the original
back. That means reflection is an <em>involution</em>, which is any function <code class="docutils literal notranslate"><span class="pre">f</span></code> such
that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">x</span></code>. Another example of an involution is multiplication by
negative one on the integers.</p>
<p>Let’s prove that <code class="docutils literal notranslate"><span class="pre">reflect</span></code> is an involution.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Claim: forall t, reflect (reflect t) = t

Proof: by induction on t.
P(t) = reflect (reflect t) = t

Base case: t = Leaf
Show: reflect (reflect Leaf) = Leaf

  reflect (reflect Leaf)
=   { evaluation }
  reflect Leaf
=   { evaluation }
  Leaf

Inductive case: t = Node (l, v, r)
IH1: reflect (reflect l) = l
IH2: reflect (reflect r) = r
Show: reflect (reflect (Node (l, v, r))) = Node (l, v, r)

  reflect (reflect (Node (l, v, r)))
=   { evaluation }
  reflect (Node (reflect r, v, reflect l))
=   { evaluation }
  Node (reflect (reflect l), v, reflect (reflect r))
=   { IH1 }
  Node (l, v, reflect (reflect r))
=   { IH2 }
  Node (l, v, r)

QED
</pre></div>
</div>
<p>Induction on trees is really no more difficult than induction on lists or
natural numbers. Just keep track of the inductive hypotheses, using our stylized
proof notation, and it isn’t hard at all.</p>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/aiJDQeWL2G0" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
</section>
<section id="induction-principles-for-all-variants">
<h2><span class="section-number">8.8.5. </span>Induction Principles for All Variants<a class="headerlink" href="#induction-principles-for-all-variants" title="Permalink to this heading">#</a></h2>
<p>We’ve now seen induction principles for <code class="docutils literal notranslate"><span class="pre">nat</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, and <code class="docutils literal notranslate"><span class="pre">tree</span></code>. Generalizing
from what we’ve seen, each constructor of a variant either generates a base case
for the inductive proof, or an inductive case. And, if a constructor itself
carries values of that data type, each of those values generates an inductive
hypothesis. For example:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Z</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Leaf</span></code> all generated base cases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code>, <code class="docutils literal notranslate"><span class="pre">::</span></code>, and <code class="docutils literal notranslate"><span class="pre">Node</span></code> all generated inductive cases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">::</span></code> each generated one IH, because each carries one value of the
data type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Node</span></code> generated two IHs, because it carries two values of the data type.</p></li>
</ul>
<p>As an example of an induction principle for a more complicated type, let’s
consider a type that represents the syntax of a mathematical expression. You
might recall from an earlier data structures course that trees can be used for
that purpose.</p>
<p>Suppose we have the following <code class="docutils literal notranslate"><span class="pre">expr</span></code> type, which is a kind of tree, to represent
expressions with integers, Booleans, unary operators, and binary operators:</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-OCaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">uop</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">UMinus</span>

<span class="k">type</span> <span class="n">bop</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">BPlus</span>
  <span class="o">|</span> <span class="nc">BMinus</span>
  <span class="o">|</span> <span class="nc">BLeq</span>

<span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span>
  <span class="o">|</span> <span class="nc">Unop</span> <span class="k">of</span> <span class="n">uop</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Binop</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">bop</span> <span class="o">*</span> <span class="n">expr</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type uop = UMinus
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type bop = BPlus | BMinus | BLeq
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>type expr =
    Int of int
  | Bool of bool
  | Unop of uop * expr
  | Binop of expr * bop * expr
</pre></div>
</div>
</div>
</details>
</div>
<p>For example, the expression <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">&lt;</span> <span class="pre">6</span></code> would be represented as
<code class="docutils literal notranslate"><span class="pre">Binop</span> <span class="pre">(Int</span> <span class="pre">5,</span> <span class="pre">BLeq,</span> <span class="pre">Int</span> <span class="pre">6)</span></code>. We’ll see more examples of this kind of
representation later in the book when we study interpreters.</p>
<p>The induction principle for <code class="docutils literal notranslate"><span class="pre">expr</span></code> is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall properties P,
  if forall i, P(Int i)
  and forall b, P(Bool b)
  and forall u e, P(e) implies P(Unop (u, e))
  and forall b e1 e2, (P(e1) and P(e2)) implies P(Binop (e1, b, e2))
  then forall e, P(e)
</pre></div>
</div>
<p>There are two base cases, corresponding to the two constructors that don’t carry
an <code class="docutils literal notranslate"><span class="pre">expr</span></code>. There are two inductive cases, corresponding to the two constructors
that do carry <code class="docutils literal notranslate"><span class="pre">expr</span></code>s. <code class="docutils literal notranslate"><span class="pre">Unop</span></code> gets one IH, whereas <code class="docutils literal notranslate"><span class="pre">Binop</span></code> gets two IHs, because
of the number of <code class="docutils literal notranslate"><span class="pre">expr</span></code>s that each carries.</p>
</section>
<section id="induction-and-recursion">
<h2><span class="section-number">8.8.6. </span>Induction and Recursion<a class="headerlink" href="#induction-and-recursion" title="Permalink to this heading">#</a></h2>
<div class="container16x9"><iframe src="https://www.youtube.com/embed/J-x9hcNqRhY" class="responsive-iframe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
<p>Inductive proofs and recursive programs bear a striking similarity. In a sense,
an inductive proof <em>is</em> a recursive program that shows how to construct evidence
for a theorem involving an algebraic data type (ADT). The <strong>structure</strong> of an ADT determines the structure of proofs and programs:</p>
<ul class="simple">
<li><p>The <strong>constructors</strong> of an ADT are the organizational principle of both proofs
and programs. In a proof, we have a base or inductive case for each
constructor. In a program, we have a pattern-matching case for each
constructor.</p></li>
<li><p>The use of <strong>recursive types</strong> in an ADT determine where recursion occurs in
both proofs and programs. By “recursive type”, we mean the occurrence of the
type in its own definition, such as the second <code class="docutils literal notranslate"><span class="pre">'a</span> <span class="pre">list</span></code> in
<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">'a</span> <span class="pre">list</span> <span class="pre">=</span> <span class="pre">[]</span> <span class="pre">|</span> <span class="pre">(</span> <span class="pre">::</span> <span class="pre">)</span> <span class="pre">'a</span> <span class="pre">*</span> <span class="pre">'a</span> <span class="pre">list</span></code>. Such occurrences lead to “smaller”
values of a type occurring inside larger values. In a proof, we apply the
inductive hypothesis upon reaching such a smaller value. In a program, we
recurse on the smaller value.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "cs3110/textbook",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "ocaml-jupyter"
        },
        kernelOptions: {
            name: "ocaml-jupyter",
            path: "./chapters/correctness"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'ocaml-jupyter'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="proving_correctness.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.7. </span>Proving Correctness</p>
      </div>
    </a>
    <a class="right-next"
       href="eq_spec.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.9. </span>Equational Specification</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-naturals">8.8.1. Induction on Naturals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-lists">8.8.2. Induction on Lists</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-theorem-about-folding">8.8.3. A Theorem about Folding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-on-trees">8.8.4. Induction on Trees</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-principles-for-all-variants">8.8.5. Induction Principles for All Variants</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#induction-and-recursion">8.8.6. Induction and Recursion</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Michael R. Clarkson et al.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=bd9e20870c6007c4c509"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=bd9e20870c6007c4c509"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>